<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="../../content/icon.ico" type="image/x-icon" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAP: Scene Management</title>
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans" rel="stylesheet">
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript">
  function inlineSVGfromIFrame () {
    console.log("blaaat")
    var alreadyImported = Boolean(document.querySelectorAll('.dyncontent svg').length)
    if (alreadyImported) return
    var allIFrames = document.querySelectorAll('.dyncontent iframe')
    var allContentBoxes = document.querySelectorAll('.dyncontent .center')
    allIFrames.forEach(function(iFrame, index) {
      var svgElem = iFrame.contentWindow.document.documentElement.cloneNode(true)
      allContentBoxes[index].appendChild(svgElem)
      iFrame.style.display = 'none'
    })
  }
  window.addEventListener("load", inlineSVGfromIFrame, false)
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://nap.tech"><img alt="Logo" src="../../nap_tech_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;"><a href="http://www.napframework.com">
   <div id="projectname">NAP
   </div>
  </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Scene Management </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../d0/d9b/scene.html#scene_overview">Overview</a></li>
<li><a class="el" href="../../d0/d9b/scene.html#scene_setup">Example</a></li>
<li><a class="el" href="../../d0/d9b/scene.html#resources_instances">Resources vs Instances</a></li>
<li><a class="el" href="../../d0/d9b/scene.html#component_ov">Components</a><ul>
<li><a class="el" href="../../d0/d9b/scene.html#creating_components">Creating Components</a><ul>
<li><a class="el" href="../../d0/d9b/scene.html#component_resource">The Resource</a></li>
<li><a class="el" href="../../d0/d9b/scene.html#component_instance">The Instance</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="../../d0/d9b/scene.html#scene_linking">Creating Links</a><ul>
<li><a class="el" href="../../d0/d9b/scene.html#component_link">To Components</a><ul>
<li><a class="el" href="../../d0/d9b/scene.html#multiple_component_link">Array of Components</a></li>
</ul>
</li>
<li><a class="el" href="../../d0/d9b/scene.html#entity_link">To Entities</a><ul>
<li><a class="el" href="../../d0/d9b/scene.html#multiple_entity_link">Array of Entities</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="../../d0/d9b/scene.html#instance_props_scene">Instance Properties</a></li>
</ul>
<h1><a class="anchor" id="scene_overview"></a>
Overview</h1>
<p>Modern applications can grow considerably in size when it comes to the amount of data they have to manage and the complex logic they need to support. NAP uses a powerful <a href="https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system" target="_blank">entity component system</a> to aid the development process. This system allows you to identify and organize all the essential parts of your application. What separates entities and components from regular resources is that they allow you to group content together in a meaningful way and update specific parts of your app at runtime. All the individual parts in the system can reference and talk to each other in a generic fashion.</p>
<p>Listed below are the most important objects and their roles within the system:</p>
<ul>
<li>Every application has one or more <a class="el" href="../../d7/d68/classnap_1_1_scene.html">scenes</a></li>
<li>A scene contains a hierarchy of <a class="el" href="../../dc/db6/classnap_1_1_entity.html">entities</a></li>
<li>Entites hold <a class="el" href="../../db/d6b/classnap_1_1_component.html">components</a></li>
<li>Components add functionality to an entity, ie: define behaviour</li>
<li>Entities and components can link to each other</li>
<li>Entities are <a class="el" href="../../d2/da9/classnap_1_1_entity_instance.html">instantiable</a>, ie: you can create multiple versions based on the same template</li>
<li><a class="el" href="../../d9/df2/classnap_1_1_component_instance.html">Components</a> are updated every frame</li>
</ul>
<h1><a class="anchor" id="scene_setup"></a>
Example</h1>
<p>Consider this example:</p>
<div class="fragment"><div class="line">Scene </div>
<div class="line">    Entity &quot;Bike&quot;</div>
<div class="line">        Component &quot;BikeInput&quot;</div>
<div class="line">        Component &quot;Transform&quot;</div>
<div class="line">        Entity &quot;Frame&quot;</div>
<div class="line">                Component &quot;Transform&quot;</div>
<div class="line">                Component &quot;RenderableMesh&quot;</div>
<div class="line">            Entity &quot;Wheel&quot;</div>
<div class="line">                Component &quot;RenderableMesh&quot;</div>
<div class="line">                Component &quot;Transform&quot;</div>
<div class="line">            Entity &quot;Wheel&quot;</div>
<div class="line">                Component &quot;RenderableMesh&quot;</div>
<div class="line">                Component &quot;Transform&quot;</div>
</div><!-- fragment --><p>In this example we have a single scene. This scene contains one 'Bike'. The bike is an entity that has two input components and one 'Frame'. The frame has two 'Wheels'. The bike, frame and wheels are entities. The names of these entities are very descriptive, they allow you to identify the different parts of the bike.</p>
<p>The 'BikeInput' component moves the entire bike in the right direction. Every entity in this scene has a position that is defined by their respective transform component. It's good to know that the position of an entity is always relative to the position of its parent entity. People that work with 3D applications should recognize this pattern.</p>
<p>In this example the bike has two wheels, one for the front and one for the back. They are both the same 'wheel' but placed differently. Other parts that could vary between wheels are the wheel color or size. What this means is that the same wheel is 'instantiated' twice, but with different properties. You can change these properties for every wheel individually but the template for both wheels is the same 'Wheel' entity.</p>
<p>You can create this structure yourself or use our editor (Napkin) to do it for you. But the end result in JSON should look something like this:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;Type&quot; : &quot;nap::Scene&quot;,</div>
<div class="line">    &quot;mID&quot;: &quot;Scene&quot;,</div>
<div class="line">    &quot;Entities&quot; : </div>
<div class="line">    [</div>
<div class="line">        {</div>
<div class="line">            &quot;Entity&quot; : &quot;Bike&quot;</div>
<div class="line">        }</div>
<div class="line">    ]</div>
<div class="line">},</div>
<div class="line">{</div>
<div class="line">    &quot;Type&quot; : &quot;nap::Entity&quot;,</div>
<div class="line">    &quot;mID&quot;: &quot;Wheel&quot;</div>
<div class="line">},</div>
<div class="line">{</div>
<div class="line">    &quot;Type&quot; : &quot;nap::Entity&quot;,</div>
<div class="line">    &quot;mID&quot;: &quot;Frame&quot;,</div>
<div class="line">    &quot;Children&quot; :</div>
<div class="line">    [</div>
<div class="line">        &quot;Wheel&quot;,</div>
<div class="line">        &quot;Wheel&quot;</div>
<div class="line">    ]</div>
<div class="line">},</div>
<div class="line">{</div>
<div class="line">    &quot;Type&quot; : &quot;nap::Entity&quot;,</div>
<div class="line">    &quot;mID&quot;: &quot;Bike&quot;,</div>
<div class="line">    &quot;Children&quot; :</div>
<div class="line">    [</div>
<div class="line">        &quot;Frame&quot;</div>
<div class="line">    ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>To make things a bit easier to read we have removed the components.</p>
<h1><a class="anchor" id="resources_instances"></a>
Resources vs Instances</h1>
<p>We briefly touched upon the difference between resources and instances in the example above. Resources are 'simple' data containers that can be authored in JSON. Resources are rather static and often remain in their original state. An instance is never part of a JSON file. An instance only exists inside the running application. NAP creates these instances for you. An <a class="el" href="../../dc/db6/classnap_1_1_entity.html">Entity</a> declared in JSON is such a resource that has a <a class="el" href="../../d2/da9/classnap_1_1_entity_instance.html">runtime counterpart</a> that is updated by NAP every frame.</p>
<p>The position of the bike (in the example above) changes as it moves through the world. The initial position of the bike is declared in JSON but the runtime position changes each frame. When there are multiple bikes in the scene, each bike has its own position. As a programmer you want to change the position of each bike programmatically, ie. set it based on a set of conditions. When you do that you modify the run-time state of a bike, not the resource that was used to create 'an instance of' the bike.</p>
<p>To summarize:</p><ul>
<li>Resources contain static, shared, read-only data</li>
<li>Instances contain runtime-varying data and can be updated each frame</li>
</ul>
<p>Both the Entity and Component have a resource and instance counterpart. NAP omits the resource part of the class name for readability:</p>
<ul>
<li>An <a class="el" href="../../dc/db6/classnap_1_1_entity.html">Entity</a> becomes an <a class="el" href="../../d2/da9/classnap_1_1_entity_instance.html">EntityInstance</a></li>
<li>A <a class="el" href="../../db/d6b/classnap_1_1_component.html">Component</a> becomes a <a class="el" href="../../d9/df2/classnap_1_1_component_instance.html">ComponentInstance</a></li>
</ul>
<p>The resources are defined in JSON. When a resources is created (instantiated) NAP creates an instance of the resource behind the scenes and adds that to the scene hierarchy. In your application scenes contain entity instances which in turn hold component instances. This structure mirrors the structure in JSON. Just remember that at run-time, in your application, you work with instances of entities and components.</p>
<h1><a class="anchor" id="component_ov"></a>
Components</h1>
<p>A scene is a container for entities and an entity is a container for components. Scenes and entities do not execute any behavior by themselves. They allow you to group and organize your objects. Components are used to add functionality to an entity, ie. defining its behavior. It is the component that receives an <a class="el" href="../../d9/df2/classnap_1_1_component_instance.html#a50e44ccbb68f2f8628caa76f6630b1dc">init()</a> and <a class="el" href="../../d9/df2/classnap_1_1_component_instance.html#a86ea8e044f33b97f2c5ea32cdb67e1d3">update()</a> call. Any programmable behavior is therefore executed in the component.</p>
<p>NAP offers a number of components off the shelf such as the <a class="el" href="../../de/d34/classnap_1_1_transform_component.html">TransformComponent</a> and <a class="el" href="../../d4/d61/classnap_1_1_renderable_mesh_component.html">RenderableMeshComponent</a>. These can be used to build hierarchies of visual objects. There are however many more components that ship with NAP. Most modules expose their own components, including: input, OSC, midi and audio components.</p>
<p>You probably want to create new components for specific tasks. The video modulation demo uses two custom components. Both components are only available to the videomodulation application. One of these components allows the user to select a shape from a selection of three-dimensional shapes. The component makes sure that every shape in the list can be rendered to screen and offers an interface to select the one to draw.</p>
<h2><a class="anchor" id="creating_components"></a>
Creating Components</h2>
<p>Every component is a resource. Everything you know about <a class="el" href="../../d9/d3b/resources.html">resources</a> also applies to components. But the component has, as mentioned before, a run time counter part in the form of an instance. To make a new component you have to create (and register) both sides: the resource and instance. The video modulation demo makes use of custom components. Refer to that code for a good working example.</p>
<h3><a class="anchor" id="component_resource"></a>
The Resource</h3>
<p>To create the resource part of a new component derive your class from <a class="el" href="../../db/d6b/classnap_1_1_component.html">Component</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NAPAPI PerspCameraComponent : <span class="keyword">public</span> Component</div>
<div class="line">{</div>
<div class="line">    RTTI_ENABLE(Component)</div>
<div class="line">    DECLARE_COMPONENT(PerspCameraComponent, PerspCameraComponentInstance)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> getDependentComponents(std::vector&lt;rtti::TypeInfo&gt;&amp; components)<span class="keyword"> const override </span></div>
<div class="line"><span class="keyword">    </span>{ </div>
<div class="line">        components.push_back(RTTI_OF(TransformComponent)); </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">float</span> mFieldOfView = 50.0f;             <span class="comment">// Property: Camera Field Of View</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>.. and register it together with the properties you need:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS(PerspCameraComponent)</div>
<div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;mFieldOfView&quot;</span>, &amp;PerspCameraComponent::mFieldOfView,  <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a>)</div>
<div class="line">RTTI_END_CLASS</div>
</div><!-- fragment --><p>Here we create a perspective camera with a field of view property. Some concepts are familiar, others are new:</p>
<ul>
<li>We derive from <a class="el" href="../../db/d6b/classnap_1_1_component.html">Component</a> instead of <a class="el" href="../../d9/dea/classnap_1_1_resource.html">Resource</a></li>
<li>The <code>DECLARE_COMPONENT</code> macro tells the system which instance of this component to create</li>
<li><a class="el" href="../../db/d6b/classnap_1_1_component.html#a22178b317d4d77ca9d2779aeef898131">getDependentComponents()</a> tells the system that this component depends on a transform</li>
</ul>
<p>If your component depends on another component you can <code>hint</code> at it. In the example above the perspective camera needs a transform to position itself in the world. NAP will make sure that if a transform is available it is initialized before the camera is initialized. Subsequently: initialization of the camera fails if the transform is not available. In JSON we can extend the scene with an entity that holds both the new component and a transform component</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;Type&quot; : &quot;nap::Scene&quot;,</div>
<div class="line">    &quot;mID&quot;: &quot;Scene&quot;, </div>
<div class="line">    &quot;Entities&quot; : </div>
<div class="line">    [</div>
<div class="line">        {</div>
<div class="line">            &quot;Entity&quot; : &quot;Bike&quot;,</div>
<div class="line">            &quot;Entity&quot; : &quot;CameraEntity&quot;</div>
<div class="line">        }</div>
<div class="line">    ]</div>
<div class="line">},</div>
<div class="line">{</div>
<div class="line">    &quot;Type&quot; : &quot;nap::Entity&quot;,</div>
<div class="line">    &quot;mID&quot;: &quot;CameraEntity&quot;,</div>
<div class="line">    &quot;Components&quot; : </div>
<div class="line">    [</div>
<div class="line">        {</div>
<div class="line">            &quot;Type&quot; : &quot;nap::PerspCameraComponent&quot;,</div>
<div class="line">            &quot;mID&quot; : &quot; PerspCameraComponent&quot;,</div>
<div class="line">            &quot;FieldOfView&quot; : 90</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            &quot;Type&quot; : &quot;nap::TransformComponent&quot;</div>
<div class="line">        }</div>
<div class="line">    ]</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="component_instance"></a>
The Instance</h3>
<p>When calling <a class="el" href="../../dc/dab/classnap_1_1_resource_manager.html#aea3f18a659081847ba254b835dc3e63b">loadFile()</a> the perspective camera component is created as part of the 'CameraEntity'. NAP will now attempt to to create the run time counterpart (instance) of the PerspCameraComponent: a PerspCameraComponentInstance. To create the instance part of a new component derive your class from <a class="el" href="../../d9/df2/classnap_1_1_component_instance.html">ComponentInstance</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NAPAPI PerspCameraComponentInstance : <span class="keyword">public</span> ComponentInstance</div>
<div class="line">{</div>
<div class="line">    RTTI_ENABLE(ComponentInstance)</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PerspCameraComponentInstance(EntityInstance&amp; entity, Component&amp; resource);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> init(utility::ErrorState&amp; errorState) <span class="keyword">override</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This part of the new component needs to be registered in the .cpp as well. Because every instance is created at run-time and never read from file you don't have to register any properties. You only register the class. The init pattern and the error handling is exactly the same as with regular resources. A small difference is the fact that this object does not contain a default constructor. The constructor of a component instance receives:</p>
<ul>
<li>the entity this component belongs to.</li>
<li>the resource that created this instance.</li>
</ul>
<p>To make sure this object can be created by NAP we have to tell the system what constructor to use. When registering the instance part you explicitly tell the system that there is no default constructor available and add one explicitly:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS_NO_DEFAULT_CONSTRUCTOR(<a class="code" href="../../d2/d87/classnap_1_1_persp_camera_component_instance.html">nap::PerspCameraComponentInstance</a>)</div>
<div class="line">    RTTI_CONSTRUCTOR(<a class="code" href="../../d2/da9/classnap_1_1_entity_instance.html">nap::EntityInstance</a>&amp;, <a class="code" href="../../db/d6b/classnap_1_1_component.html">nap::Component</a>&amp;)</div>
<div class="line">RTTI_END_CLASS</div>
</div><!-- fragment --><p>The instance part of the component is created when the file is loaded and the system encounters a 'PerspCameraComponent' resource. The instance is constructed using the registered constructor and is given the component (resource) that created it and the entity (instance) it belongs to. When the instance is initialized you know that the transform is available and everything up to that point went well. You can now safely locate the transform component and use it to (for example) compute the camera position in world space.</p>
<p>The <a class="el" href="../../d9/df2/classnap_1_1_component_instance.html#a86ea8e044f33b97f2c5ea32cdb67e1d3">update()</a> function can be overridden to add per-frame functionality to your instance. The system calls the <code>update</code> function together with a time stamp for you. The camera instance in the example above doesn't need it but other components do, for example: a component that blends two lines over time.</p>
<h1><a class="anchor" id="scene_linking"></a>
Creating Links</h1>
<p>You already know how to <a class="el" href="../../d9/d3b/resources.html#pointing">create a link</a> to a resource. But you can't use this type of link to point to components and entities. After all: there could be multiple instances of the same entity or component in your scene. When you want to point to a component you use the <a class="el" href="../../d1/dcd/classnap_1_1_component_ptr.html">ComponentPtr</a>. When you want to point to an entity you use the <a class="el" href="../../df/dec/classnap_1_1_entity_ptr.html">EntityPtr</a>. Pointing to components and entities in JSON is almost the same as pointing to stand-alone resources with one exception: you can use absolute or relative paths. It is recommended to use our editor (Napkin) to create links between objects in the scene for you.</p>
<h2><a class="anchor" id="component_link"></a>
To Components</h2>
<p>The <a class="el" href="../../d1/dcd/classnap_1_1_component_ptr.html">ComponentPtr</a> allows you to point (create a link) to another component in the scene. It works almost the same as the ObjectPtr but needs a bit of extra information to work. Let's look at the resource part of a component first:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>LineBlendComponent : <span class="keyword">public</span> Component</div>
<div class="line">{</div>
<div class="line">    RTTI_ENABLE(Component)</div>
<div class="line">    DECLARE_COMPONENT(LineBlendComponent, LineBlendComponentInstance)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// property: Link to selection component one</span></div>
<div class="line">    ComponentPtr&lt;LineSelectionComponent&gt; mSelectionComponentOne;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// property: Link to selection component two</span></div>
<div class="line">    ComponentPtr&lt;LineSelectionComponent&gt; mSelectionComponentTwo;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// property: link to the mesh to store the blend result</span></div>
<div class="line">    ResourcePtr&lt;nap::PolyLine&gt; mTarget;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This component blends two lines based on a blend value. The end result is stored in 'mTarget'. The blend target is a link to a regular resource (<a class="el" href="../../dd/d7c/classnap_1_1rtti_1_1_object_ptr.html">ResourcePtr</a>). Both input lines are extracted from a different component that live under the same entity, in this case a line selection component. Input one and two are therefore links to a different component and are required by the blend component to perform the blend operation.</p>
<p>The registration of this part of the component in the .cpp file should look familiar. Links to components are registered as regular properties:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS(nap::LineBlendComponent)</div>
<div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;SelectionOne&quot;</span>,   &amp;nap::LineBlendComponent::mSelectionComponentOne,   <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div>
<div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;SelectionTwo&quot;</span>,   &amp;nap::LineBlendComponent::mSelectionComponentOne,   <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div>
<div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;Target&quot;</span>,         &amp;nap::LineBlendComponent::mTarget,                  <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div>
<div class="line">RTTI_END_CLASS</div>
</div><!-- fragment --><p>When NAP encounters this component in JSON it tries to resolve both links for you. Both selection components are created before the blend component is created and set as links on the instance part of the blend component. But the system needs to know where to store the result of this operation. The instance part of the component exposes two members that (after serialization) link to the correct runtime version of the newly created selection components:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>LineBlendComponentInstance : <span class="keyword">public</span> ComponentInstance</div>
<div class="line">{</div>
<div class="line">    RTTI_ENABLE(ComponentInstance)</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    LineBlendComponentInstance(EntityInstance&amp; entity, Component&amp; resource) :</div>
<div class="line">        ComponentInstance(entity, resource)         {}</div>
<div class="line"> </div>
<div class="line">        ComponentInstancePtr&lt;LineSelectionComponent&gt; mSelectorOne = { <span class="keyword">this</span>, &amp;LineBlendComponent::mSelectionComponentOne };</div>
<div class="line">        ComponentInstancePtr&lt;LineSelectionComponent&gt; mSelectorTwo = { <span class="keyword">this</span>, &amp;LineBlendComponent::mSelectionComponentTwo };</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <a class="el" href="../../dc/d06/classnap_1_1_component_instance_ptr.html">ComponentInstancePtr</a> is the runtime counterpart of the <a class="el" href="../../d1/dcd/classnap_1_1_component_ptr.html">ComponentPtr</a>. Both links are set before <code>init()</code> is called. If the system can't resolve the link NAP will cancel the load operation and return an error message. The template argument is the resource part of the component this member links to. The construction arguments are always 'itself' and a reference to the original link. You don't have to specify anything else. The system will populate both members for you after construction! The registration of the instance part of the component in the .cpp is always the same:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS_NO_DEFAULT_CONSTRUCTOR(nap::LineBlendComponentInstance)</div>
<div class="line">    RTTI_CONSTRUCTOR(<a class="code" href="../../d2/da9/classnap_1_1_entity_instance.html">nap::EntityInstance</a>&amp;, <a class="code" href="../../db/d6b/classnap_1_1_component.html">nap::Component</a>&amp;)</div>
<div class="line">RTTI_END_CLASS</div>
</div><!-- fragment --><p>You can now author the links in JSON:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;Type&quot; : &quot;nap::Entity&quot;,</div>
<div class="line">    &quot;mID&quot;: &quot;LaserEntity&quot;,</div>
<div class="line">    &quot;Components&quot; : </div>
<div class="line">    [</div>
<div class="line">        {</div>
<div class="line">            &quot;Type&quot; : &quot;nap::LineSelectionComponent&quot;,</div>
<div class="line">            &quot;mID&quot; : &quot;LineSelectorOne&quot;,</div>
<div class="line">            &quot;Lines&quot; :</div>
<div class="line">            [</div>
<div class="line">                &quot;LineFromFile1&quot;,</div>
<div class="line">                &quot;LineFromFile2&quot;</div>
<div class="line">            ]</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            &quot;Type&quot; : &quot;nap::LineSelectionComponent&quot;,</div>
<div class="line">            &quot;mID&quot; : &quot;LineSelectorTwo&quot;,</div>
<div class="line">            &quot;Lines&quot; :</div>
<div class="line">            [</div>
<div class="line">                &quot;LineFromFile4&quot;,</div>
<div class="line">                &quot;LineFromFile5&quot;</div>
<div class="line">            ]</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            &quot;Type&quot; : &quot;nap::LineBlendComponent&quot;,</div>
<div class="line">            &quot;mID&quot; : &quot;LineBlender&quot;,</div>
<div class="line">            &quot;SelectionComponentOne&quot; : &quot;./LineSelectorOne&quot;,</div>
<div class="line">            &quot;SelectionComponentTwo&quot; : &quot;./LineSelectorTwo&quot;,</div>
<div class="line">            &quot;Target&quot; : &quot;LaserLineMesh1&quot;</div>
<div class="line">        }</div>
<div class="line">    ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Notice how we use a relative path? We tell the system to look for the selection component on the same entity. You can also walk further up or or down the tree to create links to other components. More on that in a later section. If there is only one component called 'LineSelectionOne' you can also link to it directly by name without specifying a relative path. In this case that would be "LineSelectorOne". Always give your component an identifier if you want to link to them.</p>
<h3><a class="anchor" id="multiple_component_link"></a>
Array of Components</h3>
<p>Instead of linking to a single component it is possible to link to multiple components at once. The components are grouped together in an array and all components in that array share the same base class. The only difference (from a single link) is that the definition and declaration of the link is a vector, just as you would normally use a vector in C++. Based on the previous example we can group both links into an array:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>LineBlendComponent : <span class="keyword">public</span> Component</div>
<div class="line">{</div>
<div class="line">    RTTI_ENABLE(Component)</div>
<div class="line">    DECLARE_COMPONENT(LineBlendComponent, LineBlendComponentInstance)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// property: Link to selection component one</span></div>
<div class="line">    std::vector&lt;ComponentPtr&lt;LineSelectionComponent&gt;&gt; mComponents;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// property: link to the mesh to store the blend result</span></div>
<div class="line">    ResourcePtr&lt;nap::PolyLine&gt; mTarget;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The registration in the .cpp file should look familiar. Instead of defining both links separately we define only the array as a property:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS(nap::LineBlendComponent)</div>
<div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;Components&quot;</span>,         &amp;nap::LineBlendComponent::mComponents,  <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div>
<div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;Target&quot;</span>,             &amp;nap::LineBlendComponent::mTarget,      <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div>
<div class="line">RTTI_END_CLASS</div>
</div><!-- fragment --><p>The instance part of the 'LineBlendComponent' also requires an array, but instead of holding a list of resources it holds a list of instances. The system automatically resolves the links for you. After initialization you are able to access the individual components immediately in your application:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>LineBlendComponentInstance : <span class="keyword">public</span> ComponentInstance</div>
<div class="line">{</div>
<div class="line">    RTTI_ENABLE(ComponentInstance)</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    LineBlendComponentInstance(EntityInstance&amp; entity, Component&amp; resource) :</div>
<div class="line">        ComponentInstance(entity, resource)         {}</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;ComponentInstancePtr&lt;LineSelectionComponent&gt;&gt; mComponents = <a class="code" href="../../d3/d14/namespacenap.html#a6b169f163cc66189fb20fd6a0a0ddca6">initComponentInstancePtr</a>(<span class="keyword">this</span>, &amp;LineBlendComponent::mComponents);</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can now add both links to the same array in JSON:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;Type&quot; : &quot;nap::Entity&quot;,</div>
<div class="line">    &quot;mID&quot;: &quot;LaserEntity&quot;,</div>
<div class="line">    &quot;Components&quot; : </div>
<div class="line">    [</div>
<div class="line">        ...</div>
<div class="line"> </div>
<div class="line">        {</div>
<div class="line">            &quot;Type&quot; : &quot;nap::LineBlendComponent&quot;,</div>
<div class="line">            &quot;mID&quot; : &quot;LineBlender&quot;,</div>
<div class="line">            &quot;Target&quot; : &quot;LaserLineMesh1&quot;,</div>
<div class="line">            &quot;Components&quot; : </div>
<div class="line">            [</div>
<div class="line">                &quot;./LineSelectorOne&quot;,</div>
<div class="line">                &quot;./LineSelectorTwo&quot;</div>
<div class="line">            ]</div>
<div class="line">        }</div>
<div class="line">    ]</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="entity_link"></a>
To Entities</h2>
<p>The <a class="el" href="../../df/dec/classnap_1_1_entity_ptr.html">EntityPtr</a> allows you to point (create a link) to another entity in the scene. They work exactly the same as a <a class="el" href="../../d0/d9b/scene.html#component_link">component pointer</a> and are created in a similar way. Notice that the template argument is not necessary because there is only one type of entity:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NAPAPI CameraController : <span class="keyword">public</span> Component</div>
<div class="line">{</div>
<div class="line">    RTTI_ENABLE(Component)</div>
<div class="line">    DECLARE_COMPONENT(CameraController, CameraControllerInstance)</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="../../df/dec/classnap_1_1_entity_ptr.html">nap::EntityPtr</a>  mLookAtTarget;          </div>
<div class="line">}</div>
</div><!-- fragment --><p>Links to entities are also a property of the component. The registration of the resource part of this component is therefore rather straight forward:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS(<a class="code" href="../../d4/dac/classnap_1_1_camera_controller.html">nap::CameraController</a>)</div>
<div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;LookAtTarget&quot;</span>,   &amp;<a class="code" href="../../d4/dac/classnap_1_1_camera_controller.html#a2114f20b93c56827d9ee99731c9b96ae">nap::CameraController::mLookAtTarget</a>,  <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div>
<div class="line">RTTI_END_CLASS</div>
</div><!-- fragment --><p>The instance also has a link to the lookat target that is resolved after load. For more information take a look at <a class="el" href="../../d0/d9b/scene.html#component_link">creating component links</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NAPAPI CameraControllerInstance : <span class="keyword">public</span> ComponentInstance</div>
<div class="line">{</div>
<div class="line">    RTTI_ENABLE(ComponentInstance)</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    CameraControllerInstance(EntityInstance&amp; entity, Component&amp; resource);</div>
<div class="line">    ...</div>
<div class="line">    EntityInstancePtr mLookAtTarget = { <span class="keyword">this</span>, &amp;CameraController::mLookAtTarget };   <span class="comment">// The resolved runtime lookat target</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>You don't have to register any properties in the .cpp file regarding the instance part of the component:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS_NO_DEFAULT_CONSTRUCTOR(<a class="code" href="../../d7/d74/classnap_1_1_camera_controller_instance.html">nap::CameraControllerInstance</a>)</div>
<div class="line">    RTTI_CONSTRUCTOR(<a class="code" href="../../d2/da9/classnap_1_1_entity_instance.html">nap::EntityInstance</a>&amp;, <a class="code" href="../../db/d6b/classnap_1_1_component.html">nap::Component</a>&amp;)</div>
<div class="line">RTTI_END_CLASS</div>
</div><!-- fragment --><p>You can now edit the link in JSON. This works the same as authoring links to components. See example above.</p>
<h3><a class="anchor" id="multiple_entity_link"></a>
Array of Entities</h3>
<p>Instead of linking to a single entity it is possible to link to multiple entities at once. The entities are grouped together in an array. The declaration of this array is the same as declaring an <a class="el" href="../../d0/d9b/scene.html#multiple_component_link">array of component pointers</a>, but uses <a class="el" href="../../d3/d14/namespacenap.html#a6852e75ca95b2c501a796bc0491b4699">'initEntityInstancePtr()'</a> instad of <a class="el" href="../../d3/d14/namespacenap.html#a6b169f163cc66189fb20fd6a0a0ddca6">'initComponentInstancePtr()'</a>. To declare an array of entity pointers as a property of a component use a standard C++ vector: <a class="el" href="../../df/dec/classnap_1_1_entity_ptr.html">'std::vector&lt;nap::EntityPtr&gt;'</a>.</p>
<h1><a class="anchor" id="instance_props_scene"></a>
Instance Properties</h1>
<p>Properties that are associated with a single instance of a component are called <a class="el" href="../../d8/d81/classnap_1_1_instance_property_value.html">instance properties</a>. Instance properties are applied on top of the default (shared) properties of a component and override the default value. This is very useful when you want to <code>spawn</code> the same entity multiple times with slightly different values, for example: the color of your 3D model.</p>
<p>Declaring instance properties in JSON is (although possible) rather difficult. Use <a class="el" href="../../da/d34/napkin.html#in_prop_override">Napkin</a> instead. The example below applies a unique z scale value to a transform component in the scene. In JSON you need to know the full path to the component, together with the property to edit on that component.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;Type&quot;: &quot;nap::Scene&quot;,</div>
<div class="line">        &quot;mID&quot; : &quot;Scene&quot;,</div>
<div class="line">        &quot;Entities&quot; : [</div>
<div class="line">    {</div>
<div class="line">        &quot;Entity&quot;: &quot;Plane&quot;,</div>
<div class="line">            &quot;InstanceProperties&quot; : [</div>
<div class="line">        {</div>
<div class="line">            &quot;TargetComponent&quot;: &quot;./nap::TransformComponent&quot;,</div>
<div class="line">                &quot;TargetAttributes&quot; : [</div>
<div class="line">            {</div>
<div class="line">                &quot;Path&quot;: &quot;Properties/Scale/z&quot;,</div>
<div class="line">                    &quot;Value&quot; : {</div>
<div class="line">                    &quot;Type&quot;: &quot;nap::FloatInstancePropertyValue&quot;,</div>
<div class="line">                        &quot;mID&quot; : &quot;instanceProp_float_dfdf2093&quot;,</div>
<div class="line">                        &quot;Value&quot; : 2.0</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">                ]</div>
<div class="line">        }</div>
<div class="line">            ]</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">        &quot;Entity&quot;: &quot;Camera&quot;,</div>
<div class="line">        &quot;InstanceProperties&quot; : []</div>
<div class="line">    }</div>
<div class="line">        ]</div>
<div class="line">},</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassnap_1_1_entity_ptr_html"><div class="ttname"><a href="../../df/dec/classnap_1_1_entity_ptr.html">nap::EntityPtr</a></div><div class="ttdef"><b>Definition:</b> entityptr.h:12</div></div>
<div class="ttc" id="aclassnap_1_1_camera_controller_html_a2114f20b93c56827d9ee99731c9b96ae"><div class="ttname"><a href="../../d4/dac/classnap_1_1_camera_controller.html#a2114f20b93c56827d9ee99731c9b96ae">nap::CameraController::mLookAtTarget</a></div><div class="ttdeci">nap::EntityPtr mLookAtTarget</div><div class="ttdoc">Property: 'LookAtTarget' Object to look at, used by the orbit and ortho controller.</div><div class="ttdef"><b>Definition:</b> cameracontroller.h:64</div></div>
<div class="ttc" id="aclassnap_1_1_camera_controller_instance_html"><div class="ttname"><a href="../../d7/d74/classnap_1_1_camera_controller_instance.html">nap::CameraControllerInstance</a></div><div class="ttdef"><b>Definition:</b> cameracontroller.h:74</div></div>
<div class="ttc" id="anamespacenap_1_1rtti_html_a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2"><div class="ttname"><a href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a></div><div class="ttdeci">@ Required</div><div class="ttdoc">Load will fail if the property isn't set.</div></div>
<div class="ttc" id="anamespacenap_html_a6b169f163cc66189fb20fd6a0a0ddca6"><div class="ttname"><a href="../../d3/d14/namespacenap.html#a6b169f163cc66189fb20fd6a0a0ddca6">nap::initComponentInstancePtr</a></div><div class="ttdeci">ComponentInstancePtrInitProxy&lt; TargetComponentType, SourceComponentType &gt; initComponentInstancePtr(ComponentInstance *sourceComponentInstance, ComponentPtr&lt; TargetComponentType &gt;(SourceComponentType::*componentMemberPointer))</div><div class="ttdef"><b>Definition:</b> componentptr.h:457</div></div>
<div class="ttc" id="aclassnap_1_1_camera_controller_html"><div class="ttname"><a href="../../d4/dac/classnap_1_1_camera_controller.html">nap::CameraController</a></div><div class="ttdef"><b>Definition:</b> cameracontroller.h:53</div></div>
<div class="ttc" id="aclassnap_1_1_entity_instance_html"><div class="ttname"><a href="../../d2/da9/classnap_1_1_entity_instance.html">nap::EntityInstance</a></div><div class="ttdef"><b>Definition:</b> entity.h:34</div></div>
<div class="ttc" id="aclassnap_1_1_component_html"><div class="ttname"><a href="../../db/d6b/classnap_1_1_component.html">nap::Component</a></div><div class="ttdef"><b>Definition:</b> component.h:152</div></div>
<div class="ttc" id="aclassnap_1_1_persp_camera_component_instance_html"><div class="ttname"><a href="../../d2/d87/classnap_1_1_persp_camera_component_instance.html">nap::PerspCameraComponentInstance</a></div><div class="ttdef"><b>Definition:</b> perspcameracomponent.h:52</div></div>
<div class="ttc" id="anamespacenap_1_1rtti_html_a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67"><div class="ttname"><a href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a></div><div class="ttdeci">@ Default</div><div class="ttdoc">Uses the (class) default if the property isn't set.</div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<a href="http://www.doxygen.org/index.html"> Generated by doxygen</a></small></address>
</body>
</html>
