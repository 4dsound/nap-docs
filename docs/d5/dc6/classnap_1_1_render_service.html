<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="../../content/icon.ico" type="image/x-icon" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAP: RenderService Class Reference</title>
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans" rel="stylesheet">
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript">
  function inlineSVGfromIFrame () {
    console.log("blaaat")
    var alreadyImported = Boolean(document.querySelectorAll('.dyncontent svg').length)
    if (alreadyImported) return
    var allIFrames = document.querySelectorAll('.dyncontent iframe')
    var allContentBoxes = document.querySelectorAll('.dyncontent .center')
    allIFrames.forEach(function(iFrame, index) {
      var svgElem = iFrame.contentWindow.document.documentElement.cloneNode(true)
      allContentBoxes[index].appendChild(svgElem)
      iFrame.style.display = 'none'
    })
  }
  window.addEventListener("load", inlineSVGfromIFrame, false)
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://nap.tech"><img alt="Logo" src="../../nap_tech_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;"><a href="http://www.napframework.com">
   <div id="projectname">NAP
   </div>
  </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d3/d14/namespacenap.html">nap</a></li><li class="navelem"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html">RenderService</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../d1/d85/classnap_1_1_render_service-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RenderService Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d5/d5b/renderservice_8h_source.html">renderservice.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d41/structnap_1_1_render_service_1_1_pipeline.html">Pipeline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa92bb343079672edca89d996db9fcfbc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aa92bb343079672edca89d996db9fcfbc">SortFunction</a> = std::function&lt; void(std::vector&lt; <a class="el" href="../../dd/da0/classnap_1_1_renderable_component_instance.html">RenderableComponentInstance</a> * &gt; &amp;, const <a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a> &amp;)&gt;</td></tr>
<tr class="separator:aa92bb343079672edca89d996db9fcfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a6dc9cab0c62751e846a6e14821304"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a31a6dc9cab0c62751e846a6e14821304">VulkanObjectDestructor</a> = std::function&lt; void(<a class="el" href="../../d5/dc6/classnap_1_1_render_service.html">RenderService</a> &amp;)&gt;</td></tr>
<tr class="separator:a31a6dc9cab0c62751e846a6e14821304"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc2f1907fffd6f1c5a2031fdc2f55183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#acc2f1907fffd6f1c5a2031fdc2f55183">RenderService</a> (<a class="el" href="../../dd/db7/classnap_1_1_service_configuration.html">ServiceConfiguration</a> *configuration)</td></tr>
<tr class="separator:acc2f1907fffd6f1c5a2031fdc2f55183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8caeeecb81d568308aab19e3100733"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#afb8caeeecb81d568308aab19e3100733">~RenderService</a> ()</td></tr>
<tr class="separator:afb8caeeecb81d568308aab19e3100733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41008e7968299cb0a4d55408f92f8209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a41008e7968299cb0a4d55408f92f8209">beginFrame</a> ()</td></tr>
<tr class="separator:a41008e7968299cb0a4d55408f92f8209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275cb0fc5850b339346d533d2e65aaa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a275cb0fc5850b339346d533d2e65aaa8">endFrame</a> ()</td></tr>
<tr class="separator:a275cb0fc5850b339346d533d2e65aaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dd7ed0e832c5b735e6e430c7374334"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a65dd7ed0e832c5b735e6e430c7374334">beginHeadlessRecording</a> ()</td></tr>
<tr class="separator:a65dd7ed0e832c5b735e6e430c7374334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb5e43ad5537bf173aa5be9fb3a4975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#abfb5e43ad5537bf173aa5be9fb3a4975">endHeadlessRecording</a> ()</td></tr>
<tr class="separator:abfb5e43ad5537bf173aa5be9fb3a4975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625ad250d47a524bf7ee8299bd627812"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a625ad250d47a524bf7ee8299bd627812">beginRecording</a> (<a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> &amp;renderWindow)</td></tr>
<tr class="separator:a625ad250d47a524bf7ee8299bd627812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbfcab6ce5509a4ab41ac04a8d7cc34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a1cbfcab6ce5509a4ab41ac04a8d7cc34">endRecording</a> ()</td></tr>
<tr class="separator:a1cbfcab6ce5509a4ab41ac04a8d7cc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99e1a12237ad7e30d33572ca874e6ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ac99e1a12237ad7e30d33572ca874e6ba">renderObjects</a> (<a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;renderTarget, <a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a> &amp;camera)</td></tr>
<tr class="separator:ac99e1a12237ad7e30d33572ca874e6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3c0366f564d9a87f4b2c393d3a0986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ada3c0366f564d9a87f4b2c393d3a0986">renderObjects</a> (<a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;renderTarget, <a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a> &amp;camera, const <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aa92bb343079672edca89d996db9fcfbc">SortFunction</a> &amp;sortFunction)</td></tr>
<tr class="separator:ada3c0366f564d9a87f4b2c393d3a0986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c079a3f1ef8f56f287ed70bdf83ef4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a56c079a3f1ef8f56f287ed70bdf83ef4">renderObjects</a> (<a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;renderTarget, <a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a> &amp;camera, const std::vector&lt; <a class="el" href="../../dd/da0/classnap_1_1_renderable_component_instance.html">RenderableComponentInstance</a> *&gt; &amp;comps)</td></tr>
<tr class="separator:a56c079a3f1ef8f56f287ed70bdf83ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08862fba10eab140f707fbf0f94d41fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a08862fba10eab140f707fbf0f94d41fd">renderObjects</a> (<a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;renderTarget, <a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a> &amp;camera, const std::vector&lt; <a class="el" href="../../dd/da0/classnap_1_1_renderable_component_instance.html">RenderableComponentInstance</a> *&gt; &amp;comps, const <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aa92bb343079672edca89d996db9fcfbc">SortFunction</a> &amp;sortFunction)</td></tr>
<tr class="separator:a08862fba10eab140f707fbf0f94d41fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e385289b7f66b9a2bcd628f0342f9a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a2e385289b7f66b9a2bcd628f0342f9a3">addWindow</a> (<a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> &amp;window, <a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;errorState)</td></tr>
<tr class="separator:a2e385289b7f66b9a2bcd628f0342f9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a3b22baad8166f097938258eb8354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a035a3b22baad8166f097938258eb8354">removeWindow</a> (<a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> &amp;window)</td></tr>
<tr class="separator:a035a3b22baad8166f097938258eb8354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3c211c81a53cb975e8f41b32e73032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a3f3c211c81a53cb975e8f41b32e73032">findWindow</a> (void *nativeWindow) const</td></tr>
<tr class="separator:a3f3c211c81a53cb975e8f41b32e73032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4ac6b010715a1dd2c6fd9bc78fdef7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a0f4ac6b010715a1dd2c6fd9bc78fdef7">findWindow</a> (<a class="el" href="../../d3/d14/namespacenap.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a> id) const</td></tr>
<tr class="separator:a0f4ac6b010715a1dd2c6fd9bc78fdef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada406dcfbc79513c0f8dab672b88f078"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ada406dcfbc79513c0f8dab672b88f078">getDisplayCount</a> () const</td></tr>
<tr class="separator:ada406dcfbc79513c0f8dab672b88f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0d26d689219c35458b45ef626e8d8a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d7c/classnap_1_1_display.html">Display</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aee0d26d689219c35458b45ef626e8d8a">findDisplay</a> (int index) const</td></tr>
<tr class="separator:aee0d26d689219c35458b45ef626e8d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e9625d7c62b572c699d7eea2f82cc5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d7c/classnap_1_1_display.html">Display</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aa1e9625d7c62b572c699d7eea2f82cc5">findDisplay</a> (const <a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">nap::RenderWindow</a> &amp;window) const</td></tr>
<tr class="separator:aa1e9625d7c62b572c699d7eea2f82cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55cdc94f4dd3e1db4a0b0efa0f61324"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d14/namespacenap.html#aae71a97f462d5a76566f1f5a3e14406f">DisplayList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ad55cdc94f4dd3e1db4a0b0efa0f61324">getDisplays</a> () const</td></tr>
<tr class="separator:ad55cdc94f4dd3e1db4a0b0efa0f61324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac963e9f22f6ac41329e8726f5e739a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aaac963e9f22f6ac41329e8726f5e739a">addEvent</a> (<a class="el" href="../../d3/d14/namespacenap.html#a47f7af3fb6c1705db816e112feb21e70">WindowEventPtr</a> windowEvent)</td></tr>
<tr class="separator:aaac963e9f22f6ac41329e8726f5e739a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace734627c0f76a438e5134f8403793b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d52/classnap_1_1_renderable_mesh.html">RenderableMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ace734627c0f76a438e5134f8403793b9">createRenderableMesh</a> (<a class="el" href="../../dd/dac/classnap_1_1_i_mesh.html">IMesh</a> &amp;mesh, <a class="el" href="../../d0/daa/classnap_1_1_material_instance.html">MaterialInstance</a> &amp;materialInstance, <a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;errorState)</td></tr>
<tr class="separator:ace734627c0f76a438e5134f8403793b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07123572cda1a183d65c8e6844c203f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d41/structnap_1_1_render_service_1_1_pipeline.html">Pipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a07123572cda1a183d65c8e6844c203f1">getOrCreatePipeline</a> (const <a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;renderTarget, const <a class="el" href="../../dd/dac/classnap_1_1_i_mesh.html">IMesh</a> &amp;mesh, const <a class="el" href="../../d0/daa/classnap_1_1_material_instance.html">MaterialInstance</a> &amp;materialInstance, <a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;errorState)</td></tr>
<tr class="separator:a07123572cda1a183d65c8e6844c203f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461dc26e2947b7517804b876bdcb2b2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d41/structnap_1_1_render_service_1_1_pipeline.html">Pipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a461dc26e2947b7517804b876bdcb2b2d">getOrCreatePipeline</a> (const <a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;renderTarget, const <a class="el" href="../../df/d52/classnap_1_1_renderable_mesh.html">RenderableMesh</a> &amp;renderableMesh, <a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;errorState)</td></tr>
<tr class="separator:a461dc26e2947b7517804b876bdcb2b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3333c08a008d46c09e86c4fbb5f29d7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a3333c08a008d46c09e86c4fbb5f29d7f">queueVulkanObjectDestructor</a> (const <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a31a6dc9cab0c62751e846a6e14821304">VulkanObjectDestructor</a> &amp;function)</td></tr>
<tr class="separator:a3333c08a008d46c09e86c4fbb5f29d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2763c7125cd26478a588068cc971dfc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d1c/classnap_1_1_descriptor_set_cache.html">DescriptorSetCache</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a2763c7125cd26478a588068cc971dfc6">getOrCreateDescriptorSetCache</a> (VkDescriptorSetLayout layout)</td></tr>
<tr class="separator:a2763c7125cd26478a588068cc971dfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513cb64b0746bd68d4007cd4ae308d31"><td class="memItemLeft" align="right" valign="top">VmaAllocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a513cb64b0746bd68d4007cd4ae308d31">getVulkanAllocator</a> () const</td></tr>
<tr class="separator:a513cb64b0746bd68d4007cd4ae308d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab267c66d8b9c40ef144035d4da339a0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ab267c66d8b9c40ef144035d4da339a0f">isHeadless</a> () const</td></tr>
<tr class="separator:ab267c66d8b9c40ef144035d4da339a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8416bd4fd7d61a3b34144dc5e616b2a3"><td class="memItemLeft" align="right" valign="top">VkCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a8416bd4fd7d61a3b34144dc5e616b2a3">getCurrentCommandBuffer</a> ()</td></tr>
<tr class="separator:a8416bd4fd7d61a3b34144dc5e616b2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de09236b9004b0ef347ef8206a21902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a0de09236b9004b0ef347ef8206a21902">getCurrentRenderWindow</a> ()</td></tr>
<tr class="separator:a0de09236b9004b0ef347ef8206a21902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37150ecc27125434d4f2422f9f447154"><td class="memItemLeft" align="right" valign="top">VkInstance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a37150ecc27125434d4f2422f9f447154">getVulkanInstance</a> () const</td></tr>
<tr class="separator:a37150ecc27125434d4f2422f9f447154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f493eba0039de8cabe34c6a65504dfa"><td class="memItemLeft" align="right" valign="top">VkPhysicalDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a4f493eba0039de8cabe34c6a65504dfa">getPhysicalDevice</a> () const</td></tr>
<tr class="separator:a4f493eba0039de8cabe34c6a65504dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e75b2ba29f65b0e2e42f6813d5745cb"><td class="memItemLeft" align="right" valign="top">const VkPhysicalDeviceFeatures &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a8e75b2ba29f65b0e2e42f6813d5745cb">getPhysicalDeviceFeatures</a> () const</td></tr>
<tr class="separator:a8e75b2ba29f65b0e2e42f6813d5745cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a6a7f844a20349a50710f2be7dea13"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ac3a6a7f844a20349a50710f2be7dea13">getPhysicalDeviceVersion</a> () const</td></tr>
<tr class="separator:ac3a6a7f844a20349a50710f2be7dea13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72855597ae5bc6e6180fb9f163d1a5e9"><td class="memItemLeft" align="right" valign="top">const VkPhysicalDeviceProperties &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a72855597ae5bc6e6180fb9f163d1a5e9">getPhysicalDeviceProperties</a> () const</td></tr>
<tr class="separator:a72855597ae5bc6e6180fb9f163d1a5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d72bec8f8b67f3a8d843aa3840f0d3b"><td class="memItemLeft" align="right" valign="top">VkDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a6d72bec8f8b67f3a8d843aa3840f0d3b">getDevice</a> () const</td></tr>
<tr class="separator:a6d72bec8f8b67f3a8d843aa3840f0d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af035eeef9fcb0782d6de4b62200f4973"><td class="memItemLeft" align="right" valign="top">VkSampleCountFlagBits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#af035eeef9fcb0782d6de4b62200f4973">getMaxRasterizationSamples</a> () const</td></tr>
<tr class="separator:af035eeef9fcb0782d6de4b62200f4973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9338fe437f9523788c2b2b974ba6f88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#af9338fe437f9523788c2b2b974ba6f88">getRasterizationSamples</a> (<a class="el" href="../../d3/d14/namespacenap.html#a0aa96290af7b249636beb86ed5b22dfb">ERasterizationSamples</a> requestedSamples, VkSampleCountFlagBits &amp;outSamples, <a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">nap::utility::ErrorState</a> &amp;errorState)</td></tr>
<tr class="separator:af9338fe437f9523788c2b2b974ba6f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b1043d881e38f5589739307d31ca0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a35b1043d881e38f5589739307d31ca0a">sampleShadingSupported</a> () const</td></tr>
<tr class="separator:a35b1043d881e38f5589739307d31ca0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3283707f946f9e647ae1a6db62b1d33f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a3283707f946f9e647ae1a6db62b1d33f">anisotropicFilteringSupported</a> () const</td></tr>
<tr class="separator:a3283707f946f9e647ae1a6db62b1d33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f11a6b565754db9834ef6df5cdbdb94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a8f11a6b565754db9834ef6df5cdbdb94">getWideLinesSupported</a> () const</td></tr>
<tr class="separator:a8f11a6b565754db9834ef6df5cdbdb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae629cabbefb35aa6b15cb55d9502b0d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ae629cabbefb35aa6b15cb55d9502b0d1">getNonSolidFillSupported</a> () const</td></tr>
<tr class="separator:ae629cabbefb35aa6b15cb55d9502b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95509a1c449e5abdc7ac70faf064ce3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a95509a1c449e5abdc7ac70faf064ce3e">getPolygonModeSupported</a> (<a class="el" href="../../d3/d14/namespacenap.html#ac68db4a0f58e015abf5b5869b1874bcf">EPolygonMode</a> mode)</td></tr>
<tr class="separator:a95509a1c449e5abdc7ac70faf064ce3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd70004e48d8d528c44552cdfaee16d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#acd70004e48d8d528c44552cdfaee16d7">getLargePointsSupported</a> () const</td></tr>
<tr class="separator:acd70004e48d8d528c44552cdfaee16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ecae5319aa21009fc1cdcf29bf07b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#af6ecae5319aa21009fc1cdcf29bf07b6">getHighDPIEnabled</a> () const</td></tr>
<tr class="separator:af6ecae5319aa21009fc1cdcf29bf07b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a83ba1d0d12685b4be308441b55af0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a6a83ba1d0d12685b4be308441b55af0d">getAnisotropicSamples</a> () const</td></tr>
<tr class="separator:a6a83ba1d0d12685b4be308441b55af0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f52c8d33d3090e21c60f3962e83e08"><td class="memItemLeft" align="right" valign="top">VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a61f52c8d33d3090e21c60f3962e83e08">getDepthFormat</a> () const</td></tr>
<tr class="separator:a61f52c8d33d3090e21c60f3962e83e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b36d1826cc90b71938882c99398a609"><td class="memItemLeft" align="right" valign="top">VkCommandPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a5b36d1826cc90b71938882c99398a609">getCommandPool</a> () const</td></tr>
<tr class="separator:a5b36d1826cc90b71938882c99398a609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5b5160be415e1e5ac957449504cf31"><td class="memItemLeft" align="right" valign="top">VkImageAspectFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aea5b5160be415e1e5ac957449504cf31">getDepthAspectFlags</a> () const</td></tr>
<tr class="separator:aea5b5160be415e1e5ac957449504cf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacabede4447b12c66bd6e6a47349097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aeacabede4447b12c66bd6e6a47349097">getQueueIndex</a> () const</td></tr>
<tr class="separator:aeacabede4447b12c66bd6e6a47349097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae507f3e4cee86281b423b1a37809339f"><td class="memItemLeft" align="right" valign="top">VkQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ae507f3e4cee86281b423b1a37809339f">getQueue</a> () const</td></tr>
<tr class="separator:ae507f3e4cee86281b423b1a37809339f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d55b0bf6bd231f9c0237e3e5d17ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d0e/classnap_1_1_texture2_d.html">Texture2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a35d55b0bf6bd231f9c0237e3e5d17ec2">getEmptyTexture</a> () const</td></tr>
<tr class="separator:a35d55b0bf6bd231f9c0237e3e5d17ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb087d12d0c788df076582aa1e0a51a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/de3/classnap_1_1_material.html">Material</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#afb087d12d0c788df076582aa1e0a51a8">getOrCreateMaterial</a> (<a class="el" href="../../d5/d40/namespacenap_1_1rtti.html#a9199873b350dca78fb3f4b2072469a3e">rtti::TypeInfo</a> shaderType, <a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;error)</td></tr>
<tr class="separator:afb087d12d0c788df076582aa1e0a51a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d99b4bafb3afe1d087e0549bb4121d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46d99b4bafb3afe1d087e0549bb4121d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/de3/classnap_1_1_material.html">Material</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a46d99b4bafb3afe1d087e0549bb4121d">getOrCreateMaterial</a> (<a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;error)</td></tr>
<tr class="separator:a46d99b4bafb3afe1d087e0549bb4121d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91f1c931ac13d3a4eb2ecaf313a8894"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ab91f1c931ac13d3a4eb2ecaf313a8894">getCurrentFrameIndex</a> () const</td></tr>
<tr class="separator:ab91f1c931ac13d3a4eb2ecaf313a8894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3feec00fb8fe154e03b64f75c6025f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#afd3feec00fb8fe154e03b64f75c6025f">getMaxFramesInFlight</a> () const</td></tr>
<tr class="separator:afd3feec00fb8fe154e03b64f75c6025f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a0d1b52c72b4d49cc0a01c34a97fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a86a0d1b52c72b4d49cc0a01c34a97fd4">getFormatProperties</a> (VkFormat format, VkFormatProperties &amp;outProperties)</td></tr>
<tr class="separator:a86a0d1b52c72b4d49cc0a01c34a97fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dba4e31f23433ef3a3c212c8c9be8c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a7dba4e31f23433ef3a3c212c8c9be8c5">isRenderingFrame</a> () const</td></tr>
<tr class="separator:a7dba4e31f23433ef3a3c212c8c9be8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73dc3e9539f2208be1d8865840d5150e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a73dc3e9539f2208be1d8865840d5150e">getVulkanVersion</a> () const</td></tr>
<tr class="separator:a73dc3e9539f2208be1d8865840d5150e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3d39f80983f0110ed99c52a7330b74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aca3d39f80983f0110ed99c52a7330b74">getVulkanVersionMajor</a> () const</td></tr>
<tr class="separator:aca3d39f80983f0110ed99c52a7330b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c814b38c6063bdcf335e9ab40a711e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ae8c814b38c6063bdcf335e9ab40a711e">getVulkanVersionMinor</a> () const</td></tr>
<tr class="separator:ae8c814b38c6063bdcf335e9ab40a711e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161d75a220f87c68d6975112f0bff3f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a161d75a220f87c68d6975112f0bff3f6">isInitialized</a> () const</td></tr>
<tr class="separator:a161d75a220f87c68d6975112f0bff3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b4203307f863795288551c40ee242f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a73b4203307f863795288551c40ee242f">waitForFence</a> (int frameIndex)</td></tr>
<tr class="separator:a73b4203307f863795288551c40ee242f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classnap_1_1_service"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classnap_1_1_service')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d8/d8e/classnap_1_1_service.html">Service</a></td></tr>
<tr class="memitem:ad7235c8709eda1d2a93808f84d9c2310 inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#ad7235c8709eda1d2a93808f84d9c2310">Service</a> (<a class="el" href="../../dd/db7/classnap_1_1_service_configuration.html">ServiceConfiguration</a> *configuration)</td></tr>
<tr class="separator:ad7235c8709eda1d2a93808f84d9c2310 inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899257490b805bae5055a997cfca81d7 inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a899257490b805bae5055a997cfca81d7">~Service</a> ()</td></tr>
<tr class="separator:a899257490b805bae5055a997cfca81d7 inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3c19c5d8d49785a63f847acc69690a inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/dfd/classnap_1_1_core.html">Core</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a2f3c19c5d8d49785a63f847acc69690a">getCore</a> ()</td></tr>
<tr class="separator:a2f3c19c5d8d49785a63f847acc69690a inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca74f25c1a5add8ce0dbafa131bb1c8 inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d0/dfd/classnap_1_1_core.html">Core</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#afca74f25c1a5add8ce0dbafa131bb1c8">getCore</a> () const</td></tr>
<tr class="separator:afca74f25c1a5add8ce0dbafa131bb1c8 inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8149d7c1b1ca3b69c739f9b1ea2b4f7e inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a8149d7c1b1ca3b69c739f9b1ea2b4f7e">getTypeName</a> () const</td></tr>
<tr class="separator:a8149d7c1b1ca3b69c739f9b1ea2b4f7e inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b8c05474371384601a411657070420 inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d25/classnap_1_1_module.html">Module</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a07b8c05474371384601a411657070420">getModule</a> () const</td></tr>
<tr class="separator:a07b8c05474371384601a411657070420 inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0dd85d53316358232364ef36e59aa2 inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a1c0dd85d53316358232364ef36e59aa2">Service</a> (<a class="el" href="../../d8/d8e/classnap_1_1_service.html">Service</a> &amp;)=delete</td></tr>
<tr class="separator:a1c0dd85d53316358232364ef36e59aa2 inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4594326a859dc6eecc268820d6e0aee inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8e/classnap_1_1_service.html">Service</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#ad4594326a859dc6eecc268820d6e0aee">operator=</a> (const <a class="el" href="../../d8/d8e/classnap_1_1_service.html">Service</a> &amp;)=delete</td></tr>
<tr class="separator:ad4594326a859dc6eecc268820d6e0aee inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52498a2168cafeeaf6fe5be29a4ec130 inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a52498a2168cafeeaf6fe5be29a4ec130">Service</a> (<a class="el" href="../../d8/d8e/classnap_1_1_service.html">Service</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a52498a2168cafeeaf6fe5be29a4ec130 inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63782c5e1b8eb5d92c32ac52e48d884 inherit pub_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8e/classnap_1_1_service.html">Service</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#ae63782c5e1b8eb5d92c32ac52e48d884">operator=</a> (<a class="el" href="../../d8/d8e/classnap_1_1_service.html">Service</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ae63782c5e1b8eb5d92c32ac52e48d884 inherit pub_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a07e39eed02aea003666b4012ac7febc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d80/classnap_1_1_signal.html">nap::Signal</a>&lt; <a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">nap::RenderWindow</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a07e39eed02aea003666b4012ac7febc1">windowAdded</a></td></tr>
<tr class="separator:a07e39eed02aea003666b4012ac7febc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11c0e8207a52339290da10fadaf7c65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d80/classnap_1_1_signal.html">nap::Signal</a>&lt; <a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">nap::RenderWindow</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ab11c0e8207a52339290da10fadaf7c65">windowRemoved</a></td></tr>
<tr class="separator:ab11c0e8207a52339290da10fadaf7c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a69d5a3e2b11484c8c85541f2bc813b01"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a69d5a3e2b11484c8c85541f2bc813b01">getDependentServices</a> (std::vector&lt; <a class="el" href="../../d5/d40/namespacenap_1_1rtti.html#a9199873b350dca78fb3f4b2072469a3e">rtti::TypeInfo</a> &gt; &amp;dependencies) override</td></tr>
<tr class="separator:a69d5a3e2b11484c8c85541f2bc813b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368fc812b8537870fc259aaded832b53"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a368fc812b8537870fc259aaded832b53">init</a> (<a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">nap::utility::ErrorState</a> &amp;errorState) override</td></tr>
<tr class="separator:a368fc812b8537870fc259aaded832b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cdd92b96df348554a627d12804af3d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#ad1cdd92b96df348554a627d12804af3d">preShutdown</a> () override</td></tr>
<tr class="separator:ad1cdd92b96df348554a627d12804af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ab4bb8705bfafcfa67e25f74f8565b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a66ab4bb8705bfafcfa67e25f74f8565b">shutdown</a> () override</td></tr>
<tr class="separator:a66ab4bb8705bfafcfa67e25f74f8565b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62852e89938526019cae34a346de31c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aa62852e89938526019cae34a346de31c">preResourcesLoaded</a> () override</td></tr>
<tr class="separator:aa62852e89938526019cae34a346de31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafcd9371afb1d28ac251b9438a17c77"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aaafcd9371afb1d28ac251b9438a17c77">update</a> (double deltaTime) override</td></tr>
<tr class="separator:aaafcd9371afb1d28ac251b9438a17c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classnap_1_1_service"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classnap_1_1_service')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../d8/d8e/classnap_1_1_service.html">Service</a></td></tr>
<tr class="memitem:a36816384ea8dd50936fa9fc93cda8e8c inherit pro_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a36816384ea8dd50936fa9fc93cda8e8c">registerObjectCreators</a> (<a class="el" href="../../d3/dcd/classnap_1_1rtti_1_1_factory.html">rtti::Factory</a> &amp;factory)</td></tr>
<tr class="separator:a36816384ea8dd50936fa9fc93cda8e8c inherit pro_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3995611d8639b1ca3bc6e76ec6b2dfa1 inherit pro_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a3995611d8639b1ca3bc6e76ec6b2dfa1">created</a> ()</td></tr>
<tr class="separator:a3995611d8639b1ca3bc6e76ec6b2dfa1 inherit pro_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85940440194983c2c8d9a8e3ae808525 inherit pro_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a85940440194983c2c8d9a8e3ae808525">preUpdate</a> (double deltaTime)</td></tr>
<tr class="separator:a85940440194983c2c8d9a8e3ae808525 inherit pro_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c80652e98b6753b4786eeefa66b9c37 inherit pro_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a7c80652e98b6753b4786eeefa66b9c37">postUpdate</a> (double deltaTime)</td></tr>
<tr class="separator:a7c80652e98b6753b4786eeefa66b9c37 inherit pro_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a645f4cdb82a96345e92a1491d3e6cc inherit pro_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a0a645f4cdb82a96345e92a1491d3e6cc">postResourcesLoaded</a> ()</td></tr>
<tr class="separator:a0a645f4cdb82a96345e92a1491d3e6cc inherit pro_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd166ef0e45bfdd38e2a654b78f958d4 inherit pro_methods_classnap_1_1_service"><td class="memTemplParams" colspan="2">template&lt;typename SERVICE_CONFIG &gt; </td></tr>
<tr class="memitem:acd166ef0e45bfdd38e2a654b78f958d4 inherit pro_methods_classnap_1_1_service"><td class="memTemplItemLeft" align="right" valign="top">SERVICE_CONFIG *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#acd166ef0e45bfdd38e2a654b78f958d4">getConfiguration</a> ()</td></tr>
<tr class="separator:acd166ef0e45bfdd38e2a654b78f958d4 inherit pro_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ec153bca85eb75335e7dae9a63ce92 inherit pro_methods_classnap_1_1_service"><td class="memTemplParams" colspan="2">template&lt;typename SERVICE_CONFIG &gt; </td></tr>
<tr class="memitem:a02ec153bca85eb75335e7dae9a63ce92 inherit pro_methods_classnap_1_1_service"><td class="memTemplItemLeft" align="right" valign="top">const SERVICE_CONFIG *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a02ec153bca85eb75335e7dae9a63ce92">getConfiguration</a> () const</td></tr>
<tr class="separator:a02ec153bca85eb75335e7dae9a63ce92 inherit pro_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da460f5356db9ddbc60d8a2abe12417 inherit pro_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#a3da460f5356db9ddbc60d8a2abe12417">getIniFilePath</a> () const</td></tr>
<tr class="separator:a3da460f5356db9ddbc60d8a2abe12417 inherit pro_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae315d6ac316ff5d4c3a76a2653e76a24 inherit pro_methods_classnap_1_1_service"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/classnap_1_1_service.html#ae315d6ac316ff5d4c3a76a2653e76a24">getIniFilePath</a> (const std::string &amp;appendix) const</td></tr>
<tr class="separator:ae315d6ac316ff5d4c3a76a2653e76a24 inherit pro_methods_classnap_1_1_service"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Main interface for 2D and 3D rendering operations.</p>
<p>This service initializes the Vulkan back-end and provides an interface to render objects to a specific target (screen or back-buffer). The service is shut down automatically on exit, and destroys all left over resources. When rendering geometry the service automatically sorts your selection based on the blend mode of the material. Opaque objects are rendered front to back, alpha blended objects are rendered back to front.</p>
<p>By default headless rendering is turned off. This means Vulkan is setup to display the result of a render operation in a <a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">nap::RenderWindow</a>, next to a <a class="el" href="../../de/dd1/classnap_1_1_render_target.html">nap::RenderTarget</a>. This requires a display device to be connected to the system. Enable headless rendering when you do NOT want to render to a window or when there is no display attached to the system. This in turn forbids the use of a <a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">nap::RenderWindow</a> inside your application.</p>
<p>When headless rendering is enabled, the engine will be initialized without surface and swapchain support, which are required by a <a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">nap::RenderWindow</a> to display images on screen. You can therefore only render to a <a class="el" href="../../de/dd1/classnap_1_1_render_target.html">nap::RenderTarget</a> when Headless rendering is enabled.</p>
<p>Turn headless rendering on / off using the <a class="el" href="../../df/d57/classnap_1_1_render_service_configuration.html">nap::RenderServiceConfiguration</a>.</p>
<p>The service creates a Vulkan 1.0 instance by default, but applications may use Vulkan 1.1 and 1.2 functionality if required. Make sure to set the required major and minor Vulkan version accordingly using the <a class="el" href="../../df/d57/classnap_1_1_render_service_configuration.html">RenderServiceConfiguration</a>. The application will not start if the device does not support the selected (and therefore required) version of Vulkan.</p>
<p>The following Vulkan device extensions are always required: VK_KHR_MAINTENANCE1_EXTENSION. When rendering to a window, the VK_KHR_SWAPCHAIN_EXTENSION is also required. Additional extension can be specified using the <a class="el" href="../../df/d57/classnap_1_1_render_service_configuration.html">nap::RenderServiceConfiguration</a>.</p>
<p>The system will try to load the requested validation layers in debug mode only. Use the <a class="el" href="../../df/d57/classnap_1_1_render_service_configuration.html">RenderServiceConfiguration</a> to specify which layers the Vulkan loader should attempt to load. A warning is issued when the validation layer can't be located or loaded. Validation layers are disabled in release mode.</p>
<p>For more information on setting up validation layers refer to: <a href="https://vulkan.lunarg.com/doc/view/1.2.131.2/windows/layer_configuration.html">https://vulkan.lunarg.com/doc/view/1.2.131.2/windows/layer_configuration.html</a></p>
<p>On initialization the service will try to choose a physical device based on the preferred GPU type. If no compatible GPU is found (even a not-preferred one) the system will fail to initialize. Most dedicated and integrated GPUs are supported. </p>
</div><div class="dynheader">
Inheritance diagram for RenderService:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d8/db6/classnap_1_1_render_service__inherit__graph.svg" width="116" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for RenderService:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d8/d24/classnap_1_1_render_service__coll__graph.svg" width="307" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="../../graph_legend.html">legend</a>]</span></center></div>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa92bb343079672edca89d996db9fcfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92bb343079672edca89d996db9fcfbc">&#9670;&nbsp;</a></span>SortFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aa92bb343079672edca89d996db9fcfbc">SortFunction</a> =  std::function&lt;void(std::vector&lt;<a class="el" href="../../dd/da0/classnap_1_1_renderable_component_instance.html">RenderableComponentInstance</a>*&gt;&amp;, const <a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31a6dc9cab0c62751e846a6e14821304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a6dc9cab0c62751e846a6e14821304">&#9670;&nbsp;</a></span>VulkanObjectDestructor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a31a6dc9cab0c62751e846a6e14821304">VulkanObjectDestructor</a> =  std::function&lt;void(<a class="el" href="../../d5/dc6/classnap_1_1_render_service.html">RenderService</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acc2f1907fffd6f1c5a2031fdc2f55183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2f1907fffd6f1c5a2031fdc2f55183">&#9670;&nbsp;</a></span>RenderService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dc6/classnap_1_1_render_service.html">RenderService</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/db7/classnap_1_1_service_configuration.html">ServiceConfiguration</a> *&#160;</td>
          <td class="paramname"><em>configuration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the service together with the provided configuration settings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configuration</td><td>render engine configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb8caeeecb81d568308aab19e3100733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8caeeecb81d568308aab19e3100733">&#9670;&nbsp;</a></span>~RenderService()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="../../d5/dc6/classnap_1_1_render_service.html">RenderService</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaac963e9f22f6ac41329e8726f5e739a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac963e9f22f6ac41329e8726f5e739a">&#9670;&nbsp;</a></span>addEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d14/namespacenap.html#a47f7af3fb6c1705db816e112feb21e70">WindowEventPtr</a>&#160;</td>
          <td class="paramname"><em>windowEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a window event that is processed later, ownership is transferred here. The window number in the event is used to find the right render window to forward the event to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowEvent</td><td>the window event to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e385289b7f66b9a2bcd628f0342f9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e385289b7f66b9a2bcd628f0342f9a3">&#9670;&nbsp;</a></span>addWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool addWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;&#160;</td>
          <td class="paramname"><em>errorState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new window as target to the render engine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>the window to add as a valid render target </td></tr>
    <tr><td class="paramname">errorState</td><td>contains the error message if the window could not be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3283707f946f9e647ae1a6db62b1d33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3283707f946f9e647ae1a6db62b1d33f">&#9670;&nbsp;</a></span>anisotropicFilteringSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool anisotropicFilteringSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if anisotropic filtering is supported </p><dl class="section return"><dt>Returns</dt><dd>if anisotropic filtering is supported </dd></dl>

</div>
</div>
<a id="a41008e7968299cb0a4d55408f92f8209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41008e7968299cb0a4d55408f92f8209">&#9670;&nbsp;</a></span>beginFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beginFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells the system you are about to render a new frame. The system might wait until all commands issued previously, associated with the same frame handle (fence), have been processed. Multiple frames are in flight at the same time, but if the graphics load is heavy, the system might wait here to ensure resources are available. Pending upload requests are executed. Previously issued download requests are checked for completion. Queued resources that are out of scope are destroyed.</p>
<p>Call this function at the beginning of the render loop, before any <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a625ad250d47a524bf7ee8299bd627812">RenderService::beginRecording()</a> calls. Make sure to call <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a275cb0fc5850b339346d533d2e65aaa8">RenderService::endFrame()</a> after all recording operations are finished, at the end of the render loop.</p>
<div class="fragment"><div class="line">mRenderService-&gt;beginFrame();</div><div class="line"><span class="keywordflow">if</span> (mRenderService-&gt;beginRecording(*mRenderWindow))</div><div class="line">{</div><div class="line">    ...</div><div class="line">    mRenderService-&gt;endRecording();</div><div class="line">}</div><div class="line">mRenderService-&gt;endFrame();</div></div><!-- fragment --> 
</div>
</div>
<a id="a65dd7ed0e832c5b735e6e430c7374334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dd7ed0e832c5b735e6e430c7374334">&#9670;&nbsp;</a></span>beginHeadlessRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool beginHeadlessRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a headless render operation. Call this when you want to render objects to a render-target instead of a render window. Make sure to call <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#abfb5e43ad5537bf173aa5be9fb3a4975">RenderService::endHeadlessRecording()</a> afterwards.</p>
<div class="fragment"><div class="line">mRenderService-&gt;beginFrame();</div><div class="line"><span class="keywordflow">if</span> (mRenderService-&gt;beginHeadlessRecording())</div><div class="line">{</div><div class="line">    ...</div><div class="line">    mRenderService-&gt;endHeadlessRecording();</div><div class="line">}</div><div class="line">mRenderService-&gt;endFrame();</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>if the headless record operation started successfully. </dd></dl>

</div>
</div>
<a id="a625ad250d47a524bf7ee8299bd627812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625ad250d47a524bf7ee8299bd627812">&#9670;&nbsp;</a></span>beginRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool beginRecording </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>renderWindow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a window render operation. Call this when you want to render geometry to a render window. Always call <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a1cbfcab6ce5509a4ab41ac04a8d7cc34">RenderService::endRecording()</a> afterwards, on success.</p>
<div class="fragment"><div class="line">mRenderService-&gt;beginFrame();</div><div class="line"><span class="keywordflow">if</span> (mRenderService-&gt;beginRecording(*mRenderWindow))</div><div class="line">{</div><div class="line">    ...</div><div class="line">    mRenderService-&gt;endRecording();</div><div class="line">}</div><div class="line">mRenderService-&gt;endFrame();</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>if the window record operation started successfully. </dd></dl>

</div>
</div>
<a id="ace734627c0f76a438e5134f8403793b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace734627c0f76a438e5134f8403793b9">&#9670;&nbsp;</a></span>createRenderableMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d52/classnap_1_1_renderable_mesh.html">RenderableMesh</a> createRenderableMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/dac/classnap_1_1_i_mesh.html">IMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/daa/classnap_1_1_material_instance.html">MaterialInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>materialInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;&#160;</td>
          <td class="paramname"><em>errorState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a renderable mesh, that represents the coupling between a mesh and material, that can be rendered to screen. Internally the renderable mesh manages a vertex array object that is issued by the render service. This function should be called from on initialization of components that work with meshes and materials: ie: all types of <a class="el" href="../../d1/d2c/classnap_1_1_renderable_component.html">RenderableComponent</a>. The result should be validated by calling <a class="el" href="../../df/d52/classnap_1_1_renderable_mesh.html#a5bc2a781be2586924afce4e4a4ea6697">RenderableMesh.isValid()</a>. Invalid mesh / material representations can't be rendered together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh that is used in the mesh-material combination. </td></tr>
    <tr><td class="paramname">materialInstance</td><td>The material instance that is used in the mesh-material combination. </td></tr>
    <tr><td class="paramname">errorState</td><td>If this function returns an invalid renderable mesh, the error state contains error information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../df/d52/classnap_1_1_renderable_mesh.html">RenderableMesh</a> object that can be used in setMesh calls. Check isValid on the object to see if creation succeeded or failed. </dd></dl>

</div>
</div>
<a id="a275cb0fc5850b339346d533d2e65aaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275cb0fc5850b339346d533d2e65aaa8">&#9670;&nbsp;</a></span>endFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void endFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells the system you finished rendering into the frame. Always call this at the end of the render() loop, after <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a41008e7968299cb0a4d55408f92f8209">RenderService::beginFrame()</a>. Failure to properly end the frame will result in a system freeze. Any pending download requests are pushed onto the command buffer.</p>
<div class="fragment"><div class="line">mRenderService-&gt;beginFrame();</div><div class="line"><span class="keywordflow">if</span> (mRenderService-&gt;beginRecording(*mRenderWindow))</div><div class="line">{</div><div class="line">    ...</div><div class="line">    mRenderService-&gt;endRecording();</div><div class="line">}</div><div class="line">mRenderService-&gt;endFrame();</div></div><!-- fragment --> 
</div>
</div>
<a id="abfb5e43ad5537bf173aa5be9fb3a4975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb5e43ad5537bf173aa5be9fb3a4975">&#9670;&nbsp;</a></span>endHeadlessRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void endHeadlessRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ends a headless render operation, submits the recorded command buffer to the queue. Always call this function after a successful call to <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a65dd7ed0e832c5b735e6e430c7374334">nap::RenderService::beginHeadlessRecording()</a>.</p>
<div class="fragment"><div class="line">mRenderService-&gt;beginFrame();</div><div class="line"><span class="keywordflow">if</span> (mRenderService-&gt;beginHeadlessRecording())</div><div class="line">{</div><div class="line">    ...</div><div class="line">    mRenderService-&gt;endHeadlessRecording();</div><div class="line">}</div><div class="line">mRenderService-&gt;endFrame();</div></div><!-- fragment --> 
</div>
</div>
<a id="a1cbfcab6ce5509a4ab41ac04a8d7cc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbfcab6ce5509a4ab41ac04a8d7cc34">&#9670;&nbsp;</a></span>endRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void endRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ends a window render operation, submits the recorded command buffer to the queue. Always call this function after a successful call to <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a625ad250d47a524bf7ee8299bd627812">nap::RenderService::beginRecording()</a>.</p>
<div class="fragment"><div class="line">mRenderService-&gt;beginFrame();</div><div class="line"><span class="keywordflow">if</span> (mRenderService-&gt;beginRecording(*mRenderWindow))</div><div class="line">{</div><div class="line">    ...</div><div class="line">    mRenderService-&gt;endRecording();</div><div class="line">}</div><div class="line">mRenderService-&gt;endFrame();</div></div><!-- fragment --> 
</div>
</div>
<a id="aee0d26d689219c35458b45ef626e8d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0d26d689219c35458b45ef626e8d8a">&#9670;&nbsp;</a></span>findDisplay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/d7c/classnap_1_1_display.html">Display</a>* findDisplay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a display based on the index provided. Note that changes to display configuration are not considered when application is running. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the number of the display to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the display, nullptr if not found </dd></dl>

</div>
</div>
<a id="aa1e9625d7c62b572c699d7eea2f82cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e9625d7c62b572c699d7eea2f82cc5">&#9670;&nbsp;</a></span>findDisplay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/d7c/classnap_1_1_display.html">Display</a>* findDisplay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">nap::RenderWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the display that currently contains the given window. </p><dl class="section return"><dt>Returns</dt><dd>display that contains the given window, nullptr if not found </dd></dl>

</div>
</div>
<a id="a3f3c211c81a53cb975e8f41b32e73032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3c211c81a53cb975e8f41b32e73032">&#9670;&nbsp;</a></span>findWindow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a>* findWindow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>nativeWindow</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a RenderWindowResource by its native handle </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nativeWindow</td><td>the native window handle (i.e. the SDL_Window pointer) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the render window associated with the native window </dd></dl>

</div>
</div>
<a id="a0f4ac6b010715a1dd2c6fd9bc78fdef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4ac6b010715a1dd2c6fd9bc78fdef7">&#9670;&nbsp;</a></span>findWindow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a>* findWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d14/namespacenap.html#a69aa29b598b851b0640aa225a9e5d61d">uint</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a <a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> based on a window number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the number of the window to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the window, nullptr if not found </dd></dl>

</div>
</div>
<a id="a6a83ba1d0d12685b4be308441b55af0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a83ba1d0d12685b4be308441b55af0d">&#9670;&nbsp;</a></span>getAnisotropicSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a> getAnisotropicSamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (system default) number of anisotropic filter samples. The output is always 1 when anisotropic filtering is not supported. </p><dl class="section return"><dt>Returns</dt><dd>system default number of max anisotropic filter samples. </dd></dl>

</div>
</div>
<a id="a5b36d1826cc90b71938882c99398a609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b36d1826cc90b71938882c99398a609">&#9670;&nbsp;</a></span>getCommandPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandPool getCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a handle to the Vulkan command pool object. Command pools are opaque objects that command buffer memory is allocated from. </p><dl class="section return"><dt>Returns</dt><dd>handle to the Vulkan command pool object. </dd></dl>

</div>
</div>
<a id="a8416bd4fd7d61a3b34144dc5e616b2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8416bd4fd7d61a3b34144dc5e616b2a3">&#9670;&nbsp;</a></span>getCurrentCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandBuffer getCurrentCommandBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the command buffer that is being recorded. Every window records into it's own command buffer. All headless render operations share the same command buffer. The current command buffer is set after nap::beginHeadlessRecording() or nap::beginRecording(RenderWindow&amp;) and only valid until the recording operation is ended. </p><dl class="section return"><dt>Returns</dt><dd>the command buffer that is being recorded. </dd></dl>

</div>
</div>
<a id="ab91f1c931ac13d3a4eb2ecaf313a8894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91f1c931ac13d3a4eb2ecaf313a8894">&#9670;&nbsp;</a></span>getCurrentFrameIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getCurrentFrameIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of the frame that is currently rendered. This index controls which command buffer is recorded and is therefore capped to the max number of images in flight. </p><dl class="section return"><dt>Returns</dt><dd>index of the currently rendered frame. </dd></dl>

</div>
</div>
<a id="a0de09236b9004b0ef347ef8206a21902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de09236b9004b0ef347ef8206a21902">&#9670;&nbsp;</a></span>getCurrentRenderWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a>* getCurrentRenderWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the window that is being rendered to, only valid between a successfull call to: <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a625ad250d47a524bf7ee8299bd627812">RenderService::beginRecording()</a> and <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a1cbfcab6ce5509a4ab41ac04a8d7cc34">RenderService::endRecording()</a>. </p><dl class="section return"><dt>Returns</dt><dd>the window currently being rendered to, nullptr if not set. </dd></dl>

</div>
</div>
<a id="a69d5a3e2b11484c8c85541f2bc813b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d5a3e2b11484c8c85541f2bc813b01">&#9670;&nbsp;</a></span>getDependentServices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void getDependentServices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d5/d40/namespacenap_1_1rtti.html#a9199873b350dca78fb3f4b2072469a3e">rtti::TypeInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dependencies</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register dependencies, render module depends on scene </p>

<p>Reimplemented from <a class="el" href="../../d8/d8e/classnap_1_1_service.html#a853a68c25fcbe373d669bbbf7bae4ba2">Service</a>.</p>

</div>
</div>
<a id="aea5b5160be415e1e5ac957449504cf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5b5160be415e1e5ac957449504cf31">&#9670;&nbsp;</a></span>getDepthAspectFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageAspectFlags getDepthAspectFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>flags that specify which depth aspects of an image are included in a view. </dd></dl>

</div>
</div>
<a id="a61f52c8d33d3090e21c60f3962e83e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f52c8d33d3090e21c60f3962e83e08">&#9670;&nbsp;</a></span>getDepthFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkFormat getDepthFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the selected and currently in use depth format. </p><dl class="section return"><dt>Returns</dt><dd>the currently selected and in use depth format. </dd></dl>

</div>
</div>
<a id="a6d72bec8f8b67f3a8d843aa3840f0d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d72bec8f8b67f3a8d843aa3840f0d3b">&#9670;&nbsp;</a></span>getDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkDevice getDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the handle to the logical Vulkan device, represents the hardware together with the extensions, selected queue and features enabled for it. </p><dl class="section return"><dt>Returns</dt><dd>The logical Vulkan device. </dd></dl>

</div>
</div>
<a id="ada406dcfbc79513c0f8dab672b88f078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada406dcfbc79513c0f8dab672b88f078">&#9670;&nbsp;</a></span>getDisplayCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getDisplayCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of displays. Note that changes to display configuration are not considered when application is running. </p><dl class="section return"><dt>Returns</dt><dd>total number of displays </dd></dl>

</div>
</div>
<a id="ad55cdc94f4dd3e1db4a0b0efa0f61324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55cdc94f4dd3e1db4a0b0efa0f61324">&#9670;&nbsp;</a></span>getDisplays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/d14/namespacenap.html#aae71a97f462d5a76566f1f5a3e14406f">DisplayList</a>&amp; getDisplays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all available displays </dd></dl>

</div>
</div>
<a id="a35d55b0bf6bd231f9c0237e3e5d17ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d55b0bf6bd231f9c0237e3e5d17ec2">&#9670;&nbsp;</a></span>getEmptyTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d0e/classnap_1_1_texture2_d.html">Texture2D</a>&amp; getEmptyTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an empty texture that is available on the GPU for temporary biding or storage. </p><dl class="section return"><dt>Returns</dt><dd>empty texture that is available on the GPU </dd></dl>

</div>
</div>
<a id="a86a0d1b52c72b4d49cc0a01c34a97fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a0d1b52c72b4d49cc0a01c34a97fd4">&#9670;&nbsp;</a></span>getFormatProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getFormatProperties </td>
          <td>(</td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormatProperties &amp;&#160;</td>
          <td class="paramname"><em>outProperties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the physical device properties for the requested Vulkan format. </p><dl class="section return"><dt>Returns</dt><dd>physical device properties for the requested Vulkan format. </dd></dl>

</div>
</div>
<a id="af6ecae5319aa21009fc1cdcf29bf07b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ecae5319aa21009fc1cdcf29bf07b6">&#9670;&nbsp;</a></span>getHighDPIEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getHighDPIEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configurable setting. When enabled fonts and general scaling is adjusted for high dpi monitors. </p><dl class="section return"><dt>Returns</dt><dd>if high dpi mode is enabled </dd></dl>

</div>
</div>
<a id="acd70004e48d8d528c44552cdfaee16d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd70004e48d8d528c44552cdfaee16d7">&#9670;&nbsp;</a></span>getLargePointsSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getLargePointsSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if rendering large points is supported. </p><dl class="section return"><dt>Returns</dt><dd>if rendering large points is supported. </dd></dl>

</div>
</div>
<a id="afd3feec00fb8fe154e03b64f75c6025f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3feec00fb8fe154e03b64f75c6025f">&#9670;&nbsp;</a></span>getMaxFramesInFlight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getMaxFramesInFlight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the max number of frames in flight. If there is only 1 frame in flight the application will stall until it is rendered. Having multiple frames in flight at once allows the render engine to start on a new frame without having to wait on the previous one to finish.</p>
<p>Increasing the number of frames in flight does however have a negative impact on resource usage, because every frame requires its own unique set of command buffers, descriptor sets etc. 2 is therefore a good number, where 3 offers only, in most situations, a slight increase in performance. This however greatly depends on the application GPU and CPU load. </p>

</div>
</div>
<a id="af035eeef9fcb0782d6de4b62200f4973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af035eeef9fcb0782d6de4b62200f4973">&#9670;&nbsp;</a></span>getMaxRasterizationSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSampleCountFlagBits getMaxRasterizationSamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the max number of hardware supported rasterization samples. </p><dl class="section return"><dt>Returns</dt><dd>the max number of rasterization samples supported by the hardware. </dd></dl>

</div>
</div>
<a id="ae629cabbefb35aa6b15cb55d9502b0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae629cabbefb35aa6b15cb55d9502b0d1">&#9670;&nbsp;</a></span>getNonSolidFillSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getNonSolidFillSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if point and wire-frame rasterization fill modes are supported. </p><dl class="section return"><dt>Returns</dt><dd>if point and wire-frame rasterization fill modes are supported </dd></dl>

</div>
</div>
<a id="a2763c7125cd26478a588068cc971dfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2763c7125cd26478a588068cc971dfc6">&#9670;&nbsp;</a></span>getOrCreateDescriptorSetCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d1c/classnap_1_1_descriptor_set_cache.html">DescriptorSetCache</a>&amp; getOrCreateDescriptorSetCache </td>
          <td>(</td>
          <td class="paramtype">VkDescriptorSetLayout&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a descriptor set cache based on the given layout. The cache is used to acquire descriptor sets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout</td><td>the descriptor set layout to create the cache for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>descriptor set cache for the given layout. </dd></dl>

</div>
</div>
<a id="afb087d12d0c788df076582aa1e0a51a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb087d12d0c788df076582aa1e0a51a8">&#9670;&nbsp;</a></span>getOrCreateMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/de3/classnap_1_1_material.html">Material</a>* getOrCreateMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d40/namespacenap_1_1rtti.html#a9199873b350dca78fb3f4b2072469a3e">rtti::TypeInfo</a>&#160;</td>
          <td class="paramname"><em>shaderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an existing or new material for the given type of shader that can be shared. This only works for hard coded shader types that can be initialized without input arguments. If initialization or creation fails, the result is cached but invalid. Use the material as a template for a material instance.</p>
<div class="fragment"><div class="line">mRenderService-&gt;getOrCreateMaterial(RTTI_OF(<a class="code" href="../../d4/d6c/classnap_1_1_font_shader.html">nap::FontShader</a>), error);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderType</td><td>type of shader to get material for. </td></tr>
    <tr><td class="paramname">error</td><td>contains the error if the material could not be created or initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new or existing material for the given shader type, nullptr if creation or initialization failed. </dd></dl>

</div>
</div>
<a id="a46d99b4bafb3afe1d087e0549bb4121d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d99b4bafb3afe1d087e0549bb4121d">&#9670;&nbsp;</a></span>getOrCreateMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/de3/classnap_1_1_material.html">Material</a>* getOrCreateMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an existing or new material for the given type of shader T that can be shared. This only works for hard coded shader types that can be initialized without input arguments. If initialization or creation fails, the result is cached but invalid. Use the material as a template for a material instance.</p>
<div class="fragment"><div class="line">mRenderService-&gt;getOrCreateMaterial&lt;<a class="code" href="../../d4/d6c/classnap_1_1_font_shader.html">nap::FontShader</a>&gt;(<a class="code" href="../../d0/de8/namespacenap_1_1icon.html#a69b152bfc7fb0055e724d38e3665049a">error</a>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>contains the error if the material could not be created or initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new or existing material for the given shader type, nullptr if creation or initialization failed. </dd></dl>

</div>
</div>
<a id="a07123572cda1a183d65c8e6844c203f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07123572cda1a183d65c8e6844c203f1">&#9670;&nbsp;</a></span>getOrCreatePipeline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d41/structnap_1_1_render_service_1_1_pipeline.html">Pipeline</a> getOrCreatePipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>renderTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/dac/classnap_1_1_i_mesh.html">IMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/daa/classnap_1_1_material_instance.html">MaterialInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>materialInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;&#160;</td>
          <td class="paramname"><em>errorState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a Vulkan pipeline for the given render target, mesh and material combination. Internally pipelines are cached, a new pipeline is created when a new combination is encountered. Because of this initial frames are slower to render, until all combinations are cached and returned from the pool. <a class="el" href="../../dd/d41/structnap_1_1_render_service_1_1_pipeline.html">Pipeline</a> creation is considered to be a heavy operation, take this into account when designing your application.</p>
<p>Use this function inside <a class="el" href="../../dd/da0/classnap_1_1_renderable_component_instance.html#a6bd53cdd277ce39e01044ef9d31dc061">nap::RenderableComponentInstance::onDraw()</a> to find the right pipeline before rendering. </p><div class="fragment"><div class="line">RenderService::Pipeline pipeline = mRenderService-&gt;getOrCreatePipeline(target, mesh, mat_instance, error_state);</div><div class="line">vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.mPipeline);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTarget</td><td>target that is rendered too. </td></tr>
    <tr><td class="paramname">mesh</td><td>the mesh that is drawn. </td></tr>
    <tr><td class="paramname">materialInstance</td><td>the material applied to the mesh. </td></tr>
    <tr><td class="paramname">errorState</td><td>contains the error if the pipeline can't be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new or cached pipeline. </dd></dl>

</div>
</div>
<a id="a461dc26e2947b7517804b876bdcb2b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461dc26e2947b7517804b876bdcb2b2d">&#9670;&nbsp;</a></span>getOrCreatePipeline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d41/structnap_1_1_render_service_1_1_pipeline.html">Pipeline</a> getOrCreatePipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>renderTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d52/classnap_1_1_renderable_mesh.html">RenderableMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>renderableMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">utility::ErrorState</a> &amp;&#160;</td>
          <td class="paramname"><em>errorState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a Vulkan pipeline for the given render target and Renderable-mesh combination. Internally pipelines are cached, a new pipeline is created when a new combination is encountered. Because of this initial frames are slower to render, until all combinations are cached and returned from the pool. <a class="el" href="../../dd/d41/structnap_1_1_render_service_1_1_pipeline.html">Pipeline</a> creation is considered to be a heavy operation, take this into account when designing your application.</p>
<p>Use this function inside <a class="el" href="../../dd/da0/classnap_1_1_renderable_component_instance.html#a6bd53cdd277ce39e01044ef9d31dc061">nap::RenderableComponentInstance::onDraw()</a> to find the right pipeline before rendering. </p><div class="fragment"><div class="line">RenderService::Pipeline pipeline = mRenderService-&gt;getOrCreatePipeline(target, render_mesh, error_state);</div><div class="line">vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.mPipeline);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTarget</td><td>target that is rendered too. </td></tr>
    <tr><td class="paramname">renderableMesh</td><td>the mesh / material combination that is rendered </td></tr>
    <tr><td class="paramname">errorState</td><td>contains the error if the pipeline can't be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new or cached pipeline. </dd></dl>

</div>
</div>
<a id="a4f493eba0039de8cabe34c6a65504dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f493eba0039de8cabe34c6a65504dfa">&#9670;&nbsp;</a></span>getPhysicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPhysicalDevice getPhysicalDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the physical device (GPU) that is used for all render operations. Multiple physical devices are not supported. </p><dl class="section return"><dt>Returns</dt><dd>Selected Vulkan hardware (GPU) device </dd></dl>

</div>
</div>
<a id="a8e75b2ba29f65b0e2e42f6813d5745cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e75b2ba29f65b0e2e42f6813d5745cb">&#9670;&nbsp;</a></span>getPhysicalDeviceFeatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const VkPhysicalDeviceFeatures&amp; getPhysicalDeviceFeatures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all supported physical device (GPU) features. </p><dl class="section return"><dt>Returns</dt><dd>all supported hardware features </dd></dl>

</div>
</div>
<a id="a72855597ae5bc6e6180fb9f163d1a5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72855597ae5bc6e6180fb9f163d1a5e9">&#9670;&nbsp;</a></span>getPhysicalDeviceProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const VkPhysicalDeviceProperties&amp; getPhysicalDeviceProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All physical device hardware properties. </p><dl class="section return"><dt>Returns</dt><dd>all hardware properties </dd></dl>

</div>
</div>
<a id="ac3a6a7f844a20349a50710f2be7dea13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a6a7f844a20349a50710f2be7dea13">&#9670;&nbsp;</a></span>getPhysicalDeviceVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t getPhysicalDeviceVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Vulkan api version, as supported by the physical device. Note that this is not the same as the api version used by the render engine. The physical device needs to support the min required api version requested by the render engine, but could be higher. </p><dl class="section return"><dt>Returns</dt><dd>the version of Vulkan supported by the device </dd></dl>

</div>
</div>
<a id="a95509a1c449e5abdc7ac70faf064ce3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95509a1c449e5abdc7ac70faf064ce3e">&#9670;&nbsp;</a></span>getPolygonModeSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getPolygonModeSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d14/namespacenap.html#ac68db4a0f58e015abf5b5869b1874bcf">EPolygonMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the selected polygon mode is supported by current selected device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the mode to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae507f3e4cee86281b423b1a37809339f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae507f3e4cee86281b423b1a37809339f">&#9670;&nbsp;</a></span>getQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkQueue getQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the selected queue, used to execute recorded command buffers. The queue must support Graphics and Transfer operations. </p><dl class="section return"><dt>Returns</dt><dd>the queue that is used to execute recorded command buffers. </dd></dl>

</div>
</div>
<a id="aeacabede4447b12c66bd6e6a47349097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacabede4447b12c66bd6e6a47349097">&#9670;&nbsp;</a></span>getQueueIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a> getQueueIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of the selected queue family. </p><dl class="section return"><dt>Returns</dt><dd>the main queue index. </dd></dl>

</div>
</div>
<a id="af9338fe437f9523788c2b2b974ba6f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9338fe437f9523788c2b2b974ba6f88">&#9670;&nbsp;</a></span>getRasterizationSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getRasterizationSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d14/namespacenap.html#a0aa96290af7b249636beb86ed5b22dfb">ERasterizationSamples</a>&#160;</td>
          <td class="paramname"><em>requestedSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSampleCountFlagBits &amp;&#160;</td>
          <td class="paramname"><em>outSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">nap::utility::ErrorState</a> &amp;&#160;</td>
          <td class="paramname"><em>errorState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns max supported rasterization samples based on the requested number of samples. The output is automatically clamped if the requested number of samples exceeds the hardware limit. </p><dl class="section return"><dt>Returns</dt><dd>if requested number of samples is supported by hardware. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requestedSamples</td><td>requested number of samples. </td></tr>
    <tr><td class="paramname">outSamples</td><td>supported number of samples. </td></tr>
    <tr><td class="paramname">errorState</td><td>contains the error if requested number of samples is not supported by the hardware. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a513cb64b0746bd68d4007cd4ae308d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513cb64b0746bd68d4007cd4ae308d31">&#9670;&nbsp;</a></span>getVulkanAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VmaAllocator getVulkanAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>main Vulkan allocator </dd></dl>

</div>
</div>
<a id="a37150ecc27125434d4f2422f9f447154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37150ecc27125434d4f2422f9f447154">&#9670;&nbsp;</a></span>getVulkanInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkInstance getVulkanInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Vulkan runtime instance. </p><dl class="section return"><dt>Returns</dt><dd>Vulkan runtime instance. </dd></dl>

</div>
</div>
<a id="a73dc3e9539f2208be1d8865840d5150e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73dc3e9539f2208be1d8865840d5150e">&#9670;&nbsp;</a></span>getVulkanVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a> getVulkanVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the api version used to create the Vulkan instance. Note that the physical device is required to support at least that version. </p><dl class="section return"><dt>Returns</dt><dd>The api version used to create the Vulkan instance. </dd></dl>

</div>
</div>
<a id="aca3d39f80983f0110ed99c52a7330b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3d39f80983f0110ed99c52a7330b74">&#9670;&nbsp;</a></span>getVulkanVersionMajor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a> getVulkanVersionMajor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the major api version used to create the Vulkan instance. The vulkan instance is created using a combination of the major and minor api version. Note that the physical device is required to support at least that version. </p><dl class="section return"><dt>Returns</dt><dd>Vulkan major api version </dd></dl>

</div>
</div>
<a id="ae8c814b38c6063bdcf335e9ab40a711e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c814b38c6063bdcf335e9ab40a711e">&#9670;&nbsp;</a></span>getVulkanVersionMinor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d14/namespacenap.html#a5522c54735d837fae7d6ba026b858441">uint32</a> getVulkanVersionMinor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minor api version used to create the Vulkan instance. The vulkan instance is created using a combination of the major and minor api version. Note that the physical device is required to support at least that version. </p><dl class="section return"><dt>Returns</dt><dd>Vulkan minor api version </dd></dl>

</div>
</div>
<a id="a8f11a6b565754db9834ef6df5cdbdb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f11a6b565754db9834ef6df5cdbdb94">&#9670;&nbsp;</a></span>getWideLinesSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getWideLinesSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if wide line rendering is supported, if so you can use a line width higher than 1. </p><dl class="section return"><dt>Returns</dt><dd>if wide line rendering is supported. </dd></dl>

</div>
</div>
<a id="a368fc812b8537870fc259aaded832b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368fc812b8537870fc259aaded832b53">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">nap::utility::ErrorState</a> &amp;&#160;</td>
          <td class="paramname"><em>errorState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the renderer, the service owns the renderer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorState</td><td>contains the error message if the service could not be initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the service has been initialized successfully </dd></dl>

<p>Reimplemented from <a class="el" href="../../d8/d8e/classnap_1_1_service.html#aeb650e2709eb5586beb1f25f55dbd830">Service</a>.</p>

</div>
</div>
<a id="ab267c66d8b9c40ef144035d4da339a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab267c66d8b9c40ef144035d4da339a0f">&#9670;&nbsp;</a></span>isHeadless()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHeadless </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if the render engine runs headless. This allows you to render images without any display device. This in turn means that when enabled it is not possible to display (present) images to a window. </p><dl class="section return"><dt>Returns</dt><dd>if the render engine runs headless. </dd></dl>

</div>
</div>
<a id="a161d75a220f87c68d6975112f0bff3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161d75a220f87c68d6975112f0bff3f6">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if the render service is running, a non operational render service is in an undefined state and can therefore not be queried </p><dl class="section return"><dt>Returns</dt><dd>if the render service is initialized and therefore running </dd></dl>

</div>
</div>
<a id="a7dba4e31f23433ef3a3c212c8c9be8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dba4e31f23433ef3a3c212c8c9be8c5">&#9670;&nbsp;</a></span>isRenderingFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isRenderingFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if the render service is currently recording (rendering) a frame. Returns true in between start and end frame calls, otherwise false. If that is the case, certain operations are not allowed. For example: data upload / download operations to and from the GPU are forbidden. </p><dl class="section return"><dt>Returns</dt><dd>if the render service is currently recording a frame. </dd></dl>

</div>
</div>
<a id="aa62852e89938526019cae34a346de31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62852e89938526019cae34a346de31c">&#9670;&nbsp;</a></span>preResourcesLoaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void preResourcesLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked when the resource manager is about to load resources. </p>

<p>Reimplemented from <a class="el" href="../../d8/d8e/classnap_1_1_service.html#a7541f05333d1fa751bed431a14e06afc">Service</a>.</p>

</div>
</div>
<a id="ad1cdd92b96df348554a627d12804af3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cdd92b96df348554a627d12804af3d">&#9670;&nbsp;</a></span>preShutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void preShutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits for the device to be idle and deletes queued resources. </p>

<p>Reimplemented from <a class="el" href="../../d8/d8e/classnap_1_1_service.html#a767c5ca86f5770046699588854b5fc82">Service</a>.</p>

</div>
</div>
<a id="a3333c08a008d46c09e86c4fbb5f29d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3333c08a008d46c09e86c4fbb5f29d7f">&#9670;&nbsp;</a></span>queueVulkanObjectDestructor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queueVulkanObjectDestructor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#a31a6dc9cab0c62751e846a6e14821304">VulkanObjectDestructor</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queues a function that destroys Vulkan resources when appropriate. Certain Vulkan resources, including buffers, image buffers etc. might still be in use when the NAP resource is destroyed. It is therefore necessary to queue their destruction, instead of deleting them immediately. Make sure that all resources are captured by copy, instead of reference.</p>
<div class="fragment"><div class="line">    mRenderService-&gt;queueVulkanObjectDestructor([buffers = mRenderBuffers](<a class="code" href="../../d5/dc6/classnap_1_1_render_service.html#acc2f1907fffd6f1c5a2031fdc2f55183">RenderService</a>&amp; service)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> BufferData&amp; buffer : buffers)</div><div class="line">    {</div><div class="line">        <a class="code" href="../../d3/d14/namespacenap.html#a26307223415c6c9a84f3fe0f0af5a51c">destroyBuffer</a>(service.getVulkanAllocator(), buffer);</div><div class="line">    }</div><div class="line">});</div></div><!-- fragment --> 
</div>
</div>
<a id="a035a3b22baad8166f097938258eb8354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035a3b22baad8166f097938258eb8354">&#9670;&nbsp;</a></span>removeWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a window as a valid target from the render engine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>the window to remove from the render service </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac99e1a12237ad7e30d33572ca874e6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99e1a12237ad7e30d33572ca874e6ba">&#9670;&nbsp;</a></span>renderObjects() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void renderObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>renderTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renders all available <a class="el" href="../../d1/d2c/classnap_1_1_renderable_component.html">nap::RenderableComponent(s)</a> in the scene to a specific renderTarget. The objects to render are sorted using the default sort function (front-to-back for opaque objects, back-to-front for transparent objects). The sort function is provided by the render service itself, using the default NAP <a class="el" href="../../d7/d0f/classnap_1_1_depth_sorter.html">DepthSorter</a>. Components that can't be rendered with the given camera are omitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTarget</td><td>the target to render to </td></tr>
    <tr><td class="paramname">camera</td><td>the camera used for rendering all the available components </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada3c0366f564d9a87f4b2c393d3a0986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3c0366f564d9a87f4b2c393d3a0986">&#9670;&nbsp;</a></span>renderObjects() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void renderObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>renderTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aa92bb343079672edca89d996db9fcfbc">SortFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>sortFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renders all available <a class="el" href="../../d1/d2c/classnap_1_1_renderable_component.html">nap::RenderableComponent(s)</a> in the scene to a specific renderTarget. Components that can't be rendered with the given camera are omitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTarget</td><td>the target to render to </td></tr>
    <tr><td class="paramname">camera</td><td>the camera used for rendering all the available components </td></tr>
    <tr><td class="paramname">sortFunction</td><td>The function used to sort the components to render </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56c079a3f1ef8f56f287ed70bdf83ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c079a3f1ef8f56f287ed70bdf83ef4">&#9670;&nbsp;</a></span>renderObjects() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void renderObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>renderTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../dd/da0/classnap_1_1_renderable_component_instance.html">RenderableComponentInstance</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>comps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renders a specific set of objects to a specific renderTarget. The objects to render are sorted using the default sort function (front-to-back for opaque objects, back-to-front for transparent objects) The sort function is provided by the render service itself, using the default NAP <a class="el" href="../../d7/d0f/classnap_1_1_depth_sorter.html">DepthSorter</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTarget</td><td>the target to render to </td></tr>
    <tr><td class="paramname">camera</td><td>the camera used for rendering all the available components </td></tr>
    <tr><td class="paramname">comps</td><td>the components to render to renderTarget </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08862fba10eab140f707fbf0f94d41fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08862fba10eab140f707fbf0f94d41fd">&#9670;&nbsp;</a></span>renderObjects() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void renderObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da9/classnap_1_1_i_render_target.html">IRenderTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>renderTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df5/classnap_1_1_camera_component_instance.html">CameraComponentInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../dd/da0/classnap_1_1_renderable_component_instance.html">RenderableComponentInstance</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>comps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dc6/classnap_1_1_render_service.html#aa92bb343079672edca89d996db9fcfbc">SortFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>sortFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renders a specific set of objects to a specific renderTarget.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTarget</td><td>the target to render to </td></tr>
    <tr><td class="paramname">camera</td><td>the camera used for rendering all the available components </td></tr>
    <tr><td class="paramname">comps</td><td>the components to render to renderTarget </td></tr>
    <tr><td class="paramname">sortFunction</td><td>The function used to sort the components to render </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35b1043d881e38f5589739307d31ca0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b1043d881e38f5589739307d31ca0a">&#9670;&nbsp;</a></span>sampleShadingSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sampleShadingSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if sample shading is supported and enabled, reduces texture aliasing at computational cost. </p><dl class="section return"><dt>Returns</dt><dd>if sample shading is supported. </dd></dl>

</div>
</div>
<a id="a66ab4bb8705bfafcfa67e25f74f8565b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ab4bb8705bfafcfa67e25f74f8565b">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shuts down the renderer, local Vulkan resources are destroyed. </p>

<p>Reimplemented from <a class="el" href="../../d8/d8e/classnap_1_1_service.html#a02ad695a12a123bb98bb8746b75c5a9d">Service</a>.</p>

</div>
</div>
<a id="aaafcd9371afb1d28ac251b9438a17c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafcd9371afb1d28ac251b9438a17c77">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void update </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Process all received window events. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deltaTime</td><td>time in seconds in between frames. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../d8/d8e/classnap_1_1_service.html#a86ea8e044f33b97f2c5ea32cdb67e1d3">Service</a>.</p>

</div>
</div>
<a id="a73b4203307f863795288551c40ee242f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b4203307f863795288551c40ee242f">&#9670;&nbsp;</a></span>waitForFence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waitForFence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frameIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for the fence belonging to the specified frame index. This ensures that, after the wait, all resources for that frame are no longer in use. You normally don't need to use this as all synchronization is handled for you. This function is only used by <a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">RenderWindow</a> to ensure that the current swap chain image is no longer in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameIndex</td><td>The index of the frame to wait for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a07e39eed02aea003666b4012ac7febc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e39eed02aea003666b4012ac7febc1">&#9670;&nbsp;</a></span>windowAdded</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d80/classnap_1_1_signal.html">nap::Signal</a>&lt;<a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">nap::RenderWindow</a>&amp;&gt; windowAdded</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when a new window is added to the system </p>

</div>
</div>
<a id="ab11c0e8207a52339290da10fadaf7c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11c0e8207a52339290da10fadaf7c65">&#9670;&nbsp;</a></span>windowRemoved</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d80/classnap_1_1_signal.html">nap::Signal</a>&lt;<a class="el" href="../../d6/d4f/classnap_1_1_render_window.html">nap::RenderWindow</a>&amp;&gt; windowRemoved</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called just before a window is removed from the system </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<a href="http://www.doxygen.org/index.html"> Generated by doxygen</a></small></address>
</body>
</html>
