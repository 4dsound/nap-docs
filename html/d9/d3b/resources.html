<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAP: Resource Management</title>
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans" rel="stylesheet">
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript">
  function inlineSVGfromIFrame () {
    console.log("blaaat")
    var alreadyImported = Boolean(document.querySelectorAll('.dyncontent svg').length)
    if (alreadyImported) return
    var allIFrames = document.querySelectorAll('.dyncontent iframe')
    var allContentBoxes = document.querySelectorAll('.dyncontent .center')
    allIFrames.forEach(function(iFrame, index) {
      var svgElem = iFrame.contentWindow.document.documentElement.cloneNode(true)
      allContentBoxes[index].appendChild(svgElem)
      iFrame.style.display = 'none'
    })
  }
  window.addEventListener("load", inlineSVGfromIFrame, false)
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="www.nap.tech"><img alt="Logo" src="../../nap_tech_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;"><a href="http://www.napframework.com">
   <div id="projectname">NAP
   </div>
  </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Resource Management </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../d9/d3b/resources.html#overview">Overview</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#creating_resources">Creating Resources</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#exposing_properties">Exposing Properties</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#pointing">Pointing to Resources</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#editing">Real Time Editing</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#media">Linking Media</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#arrays">Working With Arrays</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#structs_classes_resources">Structs, Classes and Resources</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#devices">Devices</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#embedding_objects">Embedding Objects</a></li>
<li><a class="el" href="../../d9/d3b/resources.html#embedding_pointers">Embedding Pointers</a></li>
</ul>
<h1><a class="anchor" id="overview"></a>
Overview </h1>
<p>Resources are small stand-alone building blocks that can be added to your application. Resources are used to load an image from disk, define a three-dimensional shape, create a render window, etc. All resources are objects that can be authored in <a href="https://en.wikipedia.org/wiki/JSON" target="_blank">JSON</a>. In fact: all content in NAP is authored in a readable text format. NAP uses JSON because it's a well known format that is easy to edit and read. If you don't feel like typing JSON you can use <a class="el" href="../../da/d34/napkin.html">Napkin</a> (our editor) to add, remove and modify resources. Here is an example of a JSON file that exposes two resources:</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;Objects&quot; : </div><div class="line">    [</div><div class="line">        {</div><div class="line">            &quot;Type&quot; : &quot;nap::ImageFromFile&quot;,</div><div class="line">            &quot;mID&quot; : &quot;BackgroundImage&quot;,</div><div class="line">            &quot;ImagePath&quot; : &quot;background.jpg&quot;</div><div class="line">        },</div><div class="line">        {</div><div class="line">            &quot;Type&quot; : &quot;nap::PlaneMesh&quot;,</div><div class="line">            &quot;mID&quot;: &quot;PlaneMesh&quot;</div><div class="line">        }</div><div class="line">    ]</div><div class="line">}</div></div><!-- fragment --><p>The resources mentioned above are both of a different kind and have their own set of properties. All resources in JSON have a C++ counterpart: <a class="el" href="../../dd/d82/classnap_1_1_image.html">nap::Image</a> and <a class="el" href="../../de/dd6/classnap_1_1_plane_mesh.html">nap::PlaneMesh</a> both exist as classes in the NAP C++ codebase. Both objects are created and initialized when this file is loaded. After creation the C++ properties will match the properties defined in JSON.</p>
<h1><a class="anchor" id="creating_resources"></a>
Creating Resources </h1>
<p>To make sure that C++ classes and properties can be created and edited in JSON you need to expose them explicitly through something called <a href="https://en.wikipedia.org/wiki/Run-time_type_information" target="_blank">RTTI</a> (better known as RunTime Type Information). NAP uses a number of macros to ease the way you can expose classes and properties. To create a resource that can be authored in JSON you need to derive if from <a class="el" href="../../d9/dea/classnap_1_1_resource.html">Resource</a> and tell the system what the parent object is. To accomplish this you add to the class declaration the <code>RTTI_ENABLE</code> macro:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NAPAPI Shader : <span class="keyword">public</span> Resource</div><div class="line">{</div><div class="line">    RTTI_ENABLE(Resource)</div><div class="line">};</div></div><!-- fragment --><p>And in the .cpp file, the following macros are added:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS(<a class="code" href="../../dd/d44/classnap_1_1_shader.html">nap::Shader</a>)</div><div class="line">RTTI_END_CLASS</div></div><!-- fragment --><p>This is the basis for setting up an RTTI-enabled class. In the example above we defined a shader. The <code>RTTI_ENABLE</code> macro makes sure that the system knows this class is derived from a Resource. The input for the <code>RTTI_ENABLE</code> macro is always the parent object. The code in the .cpp file exposes this class as a resource to NAP. The shader is now available as an object that can be authored in JSON.</p>
<p>The <code>NAPAPI</code> macro makes sure that the class can be read and accessed (from the outside world) by the NAP system. The compiler (on Windows) won't expose the class to the outside world when you forget to put in the <code>NAPAPI</code> macro. Remember that on startup a NAP application (automatically) loads all modules. NAP tries to find all the exposed resources that are compatible with the NAP system when loading a module. When it encounters a resource in a JSON file that is not available to the system the resource manager will raise a warning and stop execution. It is therefore important to always expose a class to the outside world using the <code>NAPAPI</code> macro.</p>
<h1><a class="anchor" id="exposing_properties"></a>
Exposing Properties </h1>
<p>Properties belong to a resource. You can think of properties as attributes and add as many as you want. To extend a resource with properties you add a property field to your class. In the example below we add two properties: 'VertPath' and 'FragPath':</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NAPAPI Shader : <span class="keyword">public</span> Resource</div><div class="line">{</div><div class="line">    RTTI_ENABLE(Resource)</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        std::string mVertPath;              <span class="comment">// Property: Path to the vertex shader on disk</span></div><div class="line">        std::string mFragPath;              <span class="comment">// Property: Path to the fragment shader on disk</span></div><div class="line">};</div></div><!-- fragment --><p>And extend the RTTI macro in the .cpp file with information about our properties:</p>
<div class="fragment"><div class="line"><span class="comment">// Adding serialzable properties</span></div><div class="line">RTTI_BEGIN_CLASS(<a class="code" href="../../dd/d44/classnap_1_1_shader.html">nap::Shader</a>)</div><div class="line">  RTTI_PROPERTY(<span class="stringliteral">&quot;VertPath&quot;</span>, &amp;nap::Shader::mFragPath, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fad1afe053f3d3b2b8db1f8397eef1841b">nap::rtti::EPropertyMetaData::FileLink</a> | <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div><div class="line">  RTTI_PROPERTY(<span class="stringliteral">&quot;FragPath&quot;</span>, &amp;nap::Shader::mVertPath, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fad1afe053f3d3b2b8db1f8397eef1841b">nap::rtti::EPropertyMetaData::FileLink</a> | <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div><div class="line">RTTI_END_CLASS</div></div><!-- fragment --><p>These properties are important. Both properties point to a file on disk that contain GLSL code that is compiled when the shader is initialized. Both properties wrap a class member: 'mFragPath' and 'mVertPath'. These are exposed to the system using the <code>RTTI_PROPERTY</code> macro. The <a class="el" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14f">EPropertyMetaData</a> enum provides additional information about properties. In this example the vertex and fragment shader paths are required. When they remain empty in JSON the resource manager won't be able to load the shader. NAP exposes the following types of properties:</p>
<ul>
<li>Default : will use the class default if the property was not set</li>
<li>Required : loading the JSON file will fail if the property was not set</li>
<li>FileLink : the property defines a relationship with an <a class="el" href="../../d9/d3b/resources.html#media">external file</a> (.bmp, .wav etc.)</li>
<li>Embedded : the property is an <a class="el" href="../../d9/d3b/resources.html#embedding_pointers">embedded pointer</a></li>
</ul>
<p>After defining the shader together with its properties, the shader can be authored in JSON:</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;Type&quot; : &quot;nap::Shader&quot;,</div><div class="line">    &quot;mID&quot; : &quot;FogShader&quot;,</div><div class="line">    &quot;VertPath&quot; : &quot;shaders/fogshader.vert&quot;</div><div class="line">    &quot;FragPath&quot; : &quot;shaders/fogshader.frag&quot;</div><div class="line">}</div></div><!-- fragment --><p>The resource identifier (<code>mID</code>) can be anything you like. The identifier is used to retrieve a resource in your application and to refer to this object by other objects in JSON. More things are possible with the RTTI system. For instance: it has support for constructors with one or more arguments and it can also expose C++ enums in a way that is still readable in JSON. See <a class="el" href="../../d1/d31/typeinfo_8h_source.html">typeinfo.h</a> or the reference documentation for more detailed information on how to do this.</p>
<h1><a class="anchor" id="pointing"></a>
Pointing to Resources </h1>
<p>It is often useful if a resource can access information from another resource. NAP allows you to create links between objects (in JSON) to accomplish just that. A resource can point to other resources in JSON by referring to the name (identifier) of a resource. In C++, we use a specific type of pointer to accomplish this: a <a class="el" href="../../d3/d14/namespacenap.html#a1275729533b054fdd0d25a42205dc0e5">resource pointer</a>. Let's assume there is a resource called 'Material' that points to a 'Shader'. The material wants to use the information stored in the shader and exposes that in the form of a link to a shader. The material can now access the shader without having to worry about order of initialization. When the material is initialized the shader has been created and validated. You only have to implement the logic you want to perform based on the information that is present in the shader:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NAPAPI Material : <span class="keyword">public</span> Resource</div><div class="line">{</div><div class="line">    RTTI_ENABLE(Resource)</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ResourcePtr&lt;nap::Shader&gt; mShader;   <span class="comment">// Property: Link to a &#39;Shader&#39; resource</span></div><div class="line">};</div></div><!-- fragment --><p>In the header the material exposes (as a member) a link to a shader in the form of an object pointer:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS(<a class="code" href="../../d2/de3/classnap_1_1_material.html">nap::Material</a>)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;Shader&quot;</span>, &amp;<a class="code" href="../../d2/de3/classnap_1_1_material.html#a15749e2904378326567d247722f08bfb">nap::Material::mShader</a>, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div><div class="line">RTTI_END_CLASS</div></div><!-- fragment --><p>In the .cpp file we register the material as a resource and add the link to a shader as a property of the material. This is similar to how we just defined the shader and its properties. We can now author these two objects in JSON. Note that the material points to the shader by its name: 'FogShader'</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;Objects&quot; : </div><div class="line">    [</div><div class="line">        {</div><div class="line">            &quot;Type&quot; : &quot;nap::Shader&quot;,</div><div class="line">            &quot;mID&quot; : &quot;FogShader&quot;,</div><div class="line">            &quot;VertPath&quot; : &quot;shaders/fogshader.vert&quot;</div><div class="line">            &quot;FragPath&quot; : &quot;shaders/fogshader.frag&quot;</div><div class="line">        }</div><div class="line"></div><div class="line">        {</div><div class="line">            &quot;Type&quot; : &quot;nap::Material&quot;,</div><div class="line">            &quot;mID&quot;  : &quot;FogMaterial&quot;,</div><div class="line">            &quot;Shader&quot;  : &quot;FogShader&quot;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The material is now registered and exposes (as as property) the link to a shader. After calling <a class="el" href="../../dc/dab/classnap_1_1_resource_manager.html#aea3f18a659081847ba254b835dc3e63b">loadfile()</a>, these two objects will be created and the pointers will be ‘resolved’. This means that they will point to the right resource. In this case the material points to a 'FogShader'. The resource manager also makes sure that the shader is initialized before the material. Cyclic dependencies are unfortunately not (yet) supported. It is not possible to point to a resource that eventually points back at the original resource. The system cannot determine the correct order of initialization in these situations.</p>
<h1><a class="anchor" id="editing"></a>
Real Time Editing </h1>
<p>NAP contains a powerful ‘real-time editing’ engine. This means that it is possible to make modifications to the JSON file while the application is running. This results in extremely fast iteration times. NAP watches the JSON file that is loaded, including any external files that are referenced (such as textures or audio files). When changes to these files are detected they are instantly hot-loaded into the system. All it takes from a user perspective is to press 'save'.</p>
<p>From a programmer perspective there are some rules to adhere to. Each resource follows the same initialization pattern. When a file is loaded, all objects are initialized in the correct order. When an init() call returns false it means that resource could not be initialized correctly. In that case, the entire load is cancelled and the system returns back to the original state before load was called. The returned error message describes what went wrong during (re)loading. It is guaranteed that all the objects remain in their original state until the initialization sequence is completed successfully. When there is no original state (ie, the file is loaded for the first time) and initialization fails the application will exit immediately.</p>
<p>Here are the rules for writing a correct <a class="el" href="../../de/d01/classnap_1_1rtti_1_1_object.html#a50e44ccbb68f2f8628caa76f6630b1dc">init</a> function:</p><ul>
<li>Return true on success, false on failure</li>
<li>Only assert (or halt program execution in any other way) on programmer errors, never on user errors</li>
<li>If the function fails make sure that a clear error message is presented to the <a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">ErrorState</a> object that is passed to init().</li>
<li>Make sure that the init() function does not have any side effects. This means that it should not update any global state. The system cannot revert such changes in case of an error.</li>
</ul>
<p><a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html">ErrorState</a> is a class that offers a convenient way to report an error to a user. The general pattern is as follows:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!errorState.check(loadImage(), <span class="stringliteral">&quot;Failed to load image %s, dimensions are unsupported (%d:%d)&quot;</span>, mPath.c_str(), mDimensions.x, mDimensions.y))</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p>The pattern is somewhat similar to the way asserts work: the first parameter is evaluated. When it evaluates to false the error message is stored in the <code>ErrorState</code> object. Notice that multiple messages can be stacked in the error object. This is convenient in many situations where a very low-level message is generated, but the context where the error occurred is missing. By nesting <a class="el" href="../../dd/d53/classnap_1_1utility_1_1_error_state.html#a0c31382459b59a3adcaa53d5dd38f55f">check()</a> calls in various functions the context can still be provided.</p>
<h1><a class="anchor" id="media"></a>
Linking Media </h1>
<p>In the <a class="el" href="../../d9/d3b/resources.html#editing">real time editing</a> section we briefly touched upon linking to external files. Some objects read information from other files. Examples include a texture resource that reads (among others) .png files or an audio player that reads .wav or .mp3 files. The real-time editing system will reload any of these external files when a modification to them is made. For this to work you need to tell the system if a property is a link to a file. You do this by marking a property of a resource as a file link:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS(Texture)</div><div class="line">  RTTI_PROPERTY(<span class="stringliteral">&quot;Path&quot;</span>, &amp;Texture::mPath, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fad1afe053f3d3b2b8db1f8397eef1841b">nap::rtti::EPropertyMetaData::FileLink</a>)</div><div class="line">RTTI_END_CLASS</div></div><!-- fragment --><h1><a class="anchor" id="arrays"></a>
Working With Arrays </h1>
<p>You can group items together into an array in JSON. This works for both links to objects as for simple compounds (structs) such as a <a class="el" href="../../d4/dd7/classnap_1_1_r_g_b_color.html">color</a>. The video modulation demo uses two arrays: one to create a group of videos and another to create a group of meshes. In the application the user can select a video or mesh based on an index.</p>
<p>Creating an array is easy. In C++ an array is a regular vector. This vector becomes a property of the resource, similar to how you normally expose a property. In the example below we add a member called 'mVideoFiles'. This is an array of video files that the user can choose from. Every video in the array is a link to an existing <a class="el" href="../../d3/d69/classnap_1_1_video.html">video</a> resource:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NAPAPI VideoContainer : <span class="keyword">public</span> rtti::RTTIObject</div><div class="line">{</div><div class="line">    RTTI_ENABLE(rtti::RTTIObject)</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    std::vector&lt;ResourcePtr&lt;Video&gt;&gt; mVideoFiles;        </div><div class="line">}</div></div><!-- fragment --><p>and in the .cpp file we register the vector as a regular property:</p>
<div class="fragment"><div class="line"><span class="comment">// nap::VideoContainer </span></div><div class="line">RTTI_BEGIN_CLASS(nap::VideoContainer)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;Videos&quot;</span>, &amp;nap::VideoContainer::mVideoFiles, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fab651efdb98a5d6bd2b3935d0c3f4a5e2">nap::rtti::EPropertyMetaData::Required</a>)</div><div class="line">RTTI_END_CLASS</div></div><!-- fragment --><p>The system recognizes that the property is an array of video links. You can now author the array in JSON:</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;Type&quot;: &quot;nap::Video&quot;,</div><div class="line">    &quot;mID&quot;: &quot;SnowVideo&quot;,</div><div class="line">    &quot;Path&quot;: &quot;snow.mp4&quot;</div><div class="line">},</div><div class="line">{</div><div class="line">    &quot;Type&quot;: &quot;nap::Video&quot;,</div><div class="line">    &quot;mID&quot;: &quot;StreakVideo&quot;,</div><div class="line">    &quot;Path&quot;: &quot;streak.mp4&quot;</div><div class="line">},</div><div class="line">{</div><div class="line">    &quot;Type&quot;: &quot;nap::VideoContainer&quot;,</div><div class="line">    &quot;mID&quot;: &quot;VideoContainer&quot;,</div><div class="line">    &quot;Videos&quot;: </div><div class="line">    [</div><div class="line">        &quot;StreakVideo&quot;,</div><div class="line">        &quot;SnowVideo&quot;</div><div class="line">    ]</div><div class="line">}</div></div><!-- fragment --><p>The example above is a simplification of the classes used in the video modulation demo.</p>
<h1><a class="anchor" id="structs_classes_resources"></a>
Structs, Classes and Resources </h1>
<p>Up to this point we only worked with resources. Resources are classes. But sometimes you want to use a simple struct to define (for example) a color or date. NAP supports structs in JSON but they have to be declared in a different way. Let's create a simple RGB color in C++:</p>
<div class="fragment"><div class="line"> <span class="comment">// RGB Color</span></div><div class="line"><span class="keyword">class </span>NAPAPI Color</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> r = 0.0f;</div><div class="line">    <span class="keywordtype">float</span> g = 0.0f;</div><div class="line">    <span class="keywordtype">float</span> b = 0.0f;</div><div class="line">};</div></div><!-- fragment --><p>As you can see the color isn't a native C++ struct but a class. This is because the RTTI system does not support C++ structs. What we do instead is label it as a struct in the .cpp file:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_STRUCT(Color)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;r&quot;</span>, &amp;Color::r, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a>)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;g&quot;</span>, &amp;Color::g, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a>)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;b&quot;</span>, &amp;Color::b, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a>)</div><div class="line">RTTI_END_STRUCT</div></div><!-- fragment --><p>So what are the advantages of using a struct? A struct is a light weight object that can be copied by value. When the system encounters a struct it is created using copy construction instead of being new'd. This is faster when the object is small and allows the editor to add and remove simple structures from an array. So in short, when you have a simple object that is:</p>
<ul>
<li>Used to group some data under a common name</li>
<li>Easy to copy</li>
<li>Not a resource</li>
<li>Necessary to edit in JSON ..</li>
</ul>
<p>.. define it as a struct.</p>
<p>In all other cases: define it as a class. But what is the difference between a class and resource? A resource is a class that can live by itself in JSON. As you know every resource carries an identifier and is initialized by NAP after construction. A resource is always derived from <a class="el" href="../../d9/dea/classnap_1_1_resource.html">Resource</a>. On the other hand, structs and classes that are not derived from Resource can't be declared in JSON as a resource because they don't have a name and can't be initialized. You can only use those objects in JSON as an <a class="el" href="../../d9/d3b/resources.html#embedding_objects">embedded object</a>. Only when a class is derived from a Resource is it considered as a resource to the system.</p>
<p>This might sound confusing but try to follow these rules: Do I need to author (edit) my class in JSON?</p><ul>
<li>Yes<ul>
<li>Is it a resource?<ul>
<li>Yes<ul>
<li>Derive your class from <a class="el" href="../../d9/dea/classnap_1_1_resource.html">Resource</a> (.h)</li>
<li>Or any object that is derived from <a class="el" href="../../d9/dea/classnap_1_1_resource.html">Resource</a> (.h)</li>
<li>Always implement the <code>RTTI_ENABLE</code> macro (.h)</li>
<li>Define it as a class (.cpp)</li>
</ul>
</li>
<li>No<ul>
<li>Is it a simple structure?<ul>
<li>Yes<ul>
<li>Don't implement the <code>RTTI_ENABLE</code> macro (.h)</li>
<li>Define it as a struct (.cpp)</li>
</ul>
</li>
<li>No<ul>
<li>Implement the <code>RTTI_ENABLE</code> macro (.h)</li>
<li>Leave the <code>RTTI_ENABLE</code> macro empty if there is no parent class (.h)</li>
<li>Define it as a class (.cpp)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>No<ul>
<li>Don't expose it to the system</li>
<li>Declare it as a regular C++ class</li>
</ul>
</li>
</ul>
<p>This diagram doesn't take <a class="el" href="../../db/d6b/classnap_1_1_component.html">components</a> into account. You can read more about components in a later <a class="el" href="../../d0/d9b/scene.html#creating_components">section</a>.</p>
<h1><a class="anchor" id="devices"></a>
Devices </h1>
<p>A <a class="el" href="../../d3/dc5/classnap_1_1_device.html">device</a> is a special type of resource. You can think of a device as a class that represents and manages the connection to an external piece of hardware (such as a DAC) or a computer. Every device has a <a class="el" href="../../d3/dc5/classnap_1_1_device.html#a6b10e199a3d6f3d0ef445aecd95700e4">start()</a> and <a class="el" href="../../d3/dc5/classnap_1_1_device.html#ae92ae13a136435391be883fd6f0f5c8c">stop()</a> method that you can override. Both methods are called by the resource manager at the appropiate time, ie: when the device is created, has changed or is removed from the resource tree. The resource manager 'stops' a device that is running before it is destroyed.</p>
<p>NAP ships with a couple of devices such as the <a class="el" href="../../dc/d99/classnap_1_1_o_s_c_receiver.html">OSCReceiver</a>, <a class="el" href="../../db/d06/classnap_1_1_o_s_c_sender.html">OSCSender</a>, <a class="el" href="../../d2/db1/classnap_1_1_art_net_controller.html">ArtnetController</a>, <a class="el" href="../../db/d61/classnap_1_1_ether_dream_dac.html">EtherDreamDac</a> etc.</p>
<h1><a class="anchor" id="embedding_objects"></a>
Embedding Objects </h1>
<p>C++ objects are often embedded into each other. For example:</p>
<div class="fragment"><div class="line"> <span class="comment">// RGB Color</span></div><div class="line"><span class="keyword">class </span>NAPAPI Color</div><div class="line">{</div><div class="line">    ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Palette that contains two colors</span></div><div class="line"><span class="keyword">class </span>NAPAPI Palette : <span class="keyword">public</span> Resource</div><div class="line">{</div><div class="line">    RTTI_ENABLE(Resource)</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Color mColorOne;        <span class="comment">// First Color of the palette</span></div><div class="line">    Color mColorTwo;        <span class="comment">// Second Color of the palette</span></div><div class="line">};</div></div><!-- fragment --><p>Here we see a 'Palette' that contains two colors. Wouldn't it be nice to assign both colors to the palette directly in JSON? As we saw <a class="el" href="../../d9/d3b/resources.html#structs_classes_resources">before</a>, a 'Color' is a struct, not a resource. We can't create a single color in JSON. But NAP can create and assign registered structs (and classes) on the fly when it encounters them in the file. We call these objects 'embedded objects', or 'compounds'. For this to work it's important that both objects have their properties registered in the .cpp file:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_STRUCT(Color)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;r&quot;</span>, &amp;Color::r, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a>)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;g&quot;</span>, &amp;Color::g, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a>)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;b&quot;</span>, &amp;Color::b, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a>)</div><div class="line">RTTI_END_STRUCT</div><div class="line"></div><div class="line">RTTI_BEGIN_CLASS(Palette)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;ColorOne&quot;</span>, &amp;Palette::mColorOne, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a>)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;ColorTwo&quot;</span>, &amp;Palette::mColorTwo, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa7a1920d61156abc05a60135aefe8bc67">nap::rtti::EPropertyMetaData::Default</a>)</div><div class="line">RTTI_END_STRUCT</div></div><!-- fragment --><p>In JSON this selection can now be authored as follows:</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;Objects&quot; : </div><div class="line">    [</div><div class="line">        {</div><div class="line">            &quot;Type&quot; : &quot;Palette&quot;,</div><div class="line">            &quot;mID&quot; : &quot;MyPalette&quot;,</div><div class="line">            &quot;ColorOne&quot; : </div><div class="line">            {</div><div class="line">                &quot;r&quot; : 0.0,</div><div class="line">                &quot;g&quot; : 0.5,</div><div class="line">                &quot;b&quot; : 0.7</div><div class="line">            },</div><div class="line">            &quot;ColorTwo&quot; : </div><div class="line">            {</div><div class="line">                &quot;r&quot; : 1.0,</div><div class="line">                &quot;g&quot; : 0.25,</div><div class="line">                &quot;b&quot; : 0.5</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>When creating the palette the system finds the two colors and assigns them on the spot. Notice that Color isn't derived from <code>RTTIObject</code>. It doesn't need to because it's not intended to be a resource. The system does however need to know the properties of a color: in this case the three color channels. You can however embed any object, including objects derived from <code>RTTIObject</code>. It's perfectly valid to embed an image into another resource directly.</p>
<h1><a class="anchor" id="embedding_pointers"></a>
Embedding Pointers </h1>
<p>Embedded objects have the benefit that their notation in JSON is rather compact. But often pointers are used to link to other objects. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// A palette container links to a color palette</span></div><div class="line"><span class="keyword">class </span>NAPAPI PaletteContainer : <span class="keyword">public</span> Resource</div><div class="line">{</div><div class="line">    RTTI_ENABLE(Resource)</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ResourcePtr&lt;Palette&gt;    mColorPalette;          <span class="comment">// Property: Link to a color palette</span></div><div class="line">};</div></div><!-- fragment --><p>In this example, PaletteContainer points to a color palette. Both the container and the color palette are root objects in the JSON file, which is sometimes messy and harder to read. For this reason, NAP supports ‘embedded pointers’. If an object logically belongs to another object, you can mark the pointer ‘embedded’, and the syntax will become similar to the way that compound objects are written. The RTTI definition in the .cpp needs to change slightly:</p>
<div class="fragment"><div class="line">RTTI_BEGIN_CLASS(Foo)</div><div class="line">    RTTI_PROPERTY(<span class="stringliteral">&quot;ColorPalette&quot;</span>, &amp;PaletteContainer::mColorPalette, <a class="code" href="../../d5/d40/namespacenap_1_1rtti.html#a1f535c4edd3778687698eb3e5447f14fa069e7821d3b4c0bbf437147263eb4d0e">nap::rtti::EPropertyMetaData::Embedded</a>)</div><div class="line">RTTI_END_CLASS</div></div><!-- fragment --><p>We can write this in JSON as follows:</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;Objects&quot; : </div><div class="line">    [</div><div class="line">        {</div><div class="line">            &quot;Type&quot; : &quot;PaletteContainer&quot;,</div><div class="line">            &quot;mID&quot; : &quot;MyPaletteContainer&quot;,</div><div class="line">            &quot;ColorPalette&quot; : </div><div class="line">            {</div><div class="line">                &quot;ColorOne&quot; : </div><div class="line">                {</div><div class="line">                    &quot;r&quot; : 0.0,</div><div class="line">                    &quot;g&quot; : 0.5,</div><div class="line">                    &quot;b&quot; : 0.7</div><div class="line">                },</div><div class="line">                &quot;ColorTwo&quot; : </div><div class="line">                {</div><div class="line">                    &quot;r&quot; : 1.0,</div><div class="line">                    &quot;g&quot; : 0.25,</div><div class="line">                    &quot;b&quot; : 0.5</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Note that the embedded object is still a regular object that lives inside the <a class="el" href="../../dc/dab/classnap_1_1_resource_manager.html">resource manager</a>. The identifier can be omitted in JSON, in that case an identifier will be generated for you. If you declare an identifier you can still find it by that name in the resource manager. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<a href="http://www.doxygen.org/index.html"> Generated by doxygen</a></small></address>
</body>
</html>
